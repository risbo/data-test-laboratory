✅ Object-Oriented Programming (OOP) in Kotlin
Classes and Objects (class, object, init, constructors)
Inheritance and open/override modifiers
Encapsulation (private, protected, public, internal visibility)
Polymorphism (method overriding, interface implementation)
Abstraction (abstract classes and interfaces)
Composition over inheritance (using properties instead of subclassing)
Data Classes (auto-generated equals, hashCode, copy)
sealed and enum classes for restricted hierarchies
Delegation (by keyword, interface delegation)
SOLID Principles (Single Responsibility, Open/Closed, etc.)
✅ Functional Programming in Kotlin
First-class and higher-order functions
Lambda expressions and function references
map, filter, reduce, fold, flatMap, etc.
Immutability and pure functions
Extension functions and properties
Recursion and tail recursion
Function composition and chaining
Partial application and currying (via lambdas or custom wrappers)
let, run, apply, also, with (functional-style scope control)
✅ Declarative and Reactive Paradigms
DSL construction using lambdas with receivers
Builders (apply, buildString, custom DSLs)
Flow, StateFlow, and SharedFlow for reactive streams
Event-driven programming with callbackFlow, Channel, coroutines
Unidirectional Data Flow (used in UI frameworks like Jetpack Compose)
✅ Other Paradigms and Concepts
Procedural (basic top-down logic with reusable functions)
Event-Driven (using listeners, coroutines, channels)
Imperative vs Declarative distinctions
Asynchronous Programming (suspend, coroutines, structured concurrency)
Actor Model (limited via Channel + coroutine scopes)
