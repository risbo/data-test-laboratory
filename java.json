{
  "id": 9,
  "topic": 1,
  "data": [
    {
  "id": 10,
  "topic": "Atomic Operations",
  "question": "What thread-safety guarantee does ConcurrentHashMap's compute() method provide for the remapping function?\n\n\t- Atomic execution per key\n\t- Process-wide exclusivity\n\t- Only single-writer guarantee\n\t- No guarantees under high contention",
  "options": [
    "Per-key atomicity",
    "Global exclusivity",
    "Single-writer",
    "No guarantees"
  ],
  "response": "Per-key atomicity",
  "explanation": "Title: CHM Atomic Computations\n\nLocks only the affected hash bucket during compute(), allowing concurrent operations on other keys.\n\nExample 1:\nmap.compute(key, (k,v) -> v+1); // Atomic for this key\n\nExample 2:\n// Internal implementation:\nsynchronized (f) { // Node lock\n  if (tabAt(tab, i) == f) ...\n\nExample 3:\n// Concurrent update:\nmap.compute(keyA, ...); // Runs concurrently with\nmap.compute(keyB, ...);",
  "keywords": ["ConcurrentHashMap", "compute", "atomic", "per-key locking", "remapping", "thread-safe", "bucket"]
},
    {
  "id": 9,
  "topic": "Legacy Thread Safety",
  "question": "What critical difference exists between Vector and Collections.synchronizedList(new ArrayList())?\n\n\t- Vector synchronizes per method while synchronizedList uses a mutex\n\t- Only Vector supports concurrent iteration\n\t- synchronizedList has better memory locality\n\t- Vector uses copy-on-write internally",
  "options": [
    "Different lock mechanisms",
    "Vector allows concurrent iteration",
    "Better memory layout",
    "Copy-on-write"
  ],
  "response": "Different lock mechanisms",
  "explanation": "Title: Legacy Synchronization Approaches\n\nVector synchronizes on instance while synchronizedList uses separate mutex object, affecting extensibility.\n\nExample 1:\n// Vector synchronization:\npublic synchronized boolean add(E e) { ... }\n\nExample 2:\n// synchronizedList wrapper:\nfinal Object mutex;\npublic boolean add(E e) {\n  synchronized (mutex) { ... }\n\nExample 3:\n// Extension risk:\nclass CustomList extends Vector {...} // Inherits sync\nclass CustomList extends ArrayList {...} // Needs manual sync",
  "keywords": ["Vector", "synchronizedList", "legacy", "mutex", "inheritance", "extension", "locking"]
},
    {
  "id": 8,
  "topic": "Fail-Fast Behavior",
  "question": "What internal mechanism triggers ArrayList's ConcurrentModificationException during structural modifications?\n\n\t- Version counter in AbstractList\n\t- Hash code verification\n\t- Iterator's expectedModCount field\n\t- Thread-local modification stamps",
  "options": [
    "expectedModCount check",
    "Hash verification",
    "Version counter",
    "Thread stamps"
  ],
  "response": "expectedModCount check",
  "explanation": "Title: Fail-Fast Implementation\n\nIterators compare modCount against expectedModCount to detect concurrent structural changes.\n\nExample 1:\nArrayList<String> list = ...\nIterator<String> it = list.iterator();\nlist.add(\"new\"); // modCount++\nit.next(); // Checks modCount != expectedModCount\n\nExample 2:\n// AbstractList fields:\nprotected transient int modCount;\n\nExample 3:\n// Iterator initialization:\nint expectedModCount = modCount;",
  "keywords": ["ConcurrentModificationException", "fail-fast", "modCount", "expectedModCount", "iterator", "structural modification", "ArrayList"]
},
    {
  "id": 7,
  "topic": "Reference-Based Collections",
  "question": "When does WeakHashMap automatically purge entries after key garbage collection?\n\n\t- During next put/get operation\n\t- Immediately via ReferenceQueue\n\t- Only during full GC cycles\n\t- When explicitly calling size()",
  "options": [
    "During map operations",
    "Via ReferenceQueue",
    "Full GC only",
    "On size() calls"
  ],
  "response": "During map operations",
  "explanation": "Title: WeakHashMap Cleanup Mechanism\n\nExpunges stale entries during subsequent map operations via ReferenceQueue polling.\n\nExample 1:\nWeakHashMap<Key,Value> map = new ...\nKey k = new Key();\nmap.put(k, value);\nk = null; // Eligible for GC\nmap.get(new Key()); // Triggers cleanup\n\nExample 2:\n// Internal expunge:\nprivate void expungeStaleEntries() {\n  while ((x = queue.poll()) != null) ...\n\nExample 3:\n// Reference queue usage\nprivate final ReferenceQueue<Object> queue = new ...",
  "keywords": ["WeakHashMap", "garbage collection", "ReferenceQueue", "expunge", "weak references", "cleanup", "map operations"]
},
    {
  "id": 6,
  "topic": "Non-Blocking Queues",
  "question": "What distinguishes ConcurrentLinkedQueue's poll() from peek() in terms of thread visibility guarantees?\n\n\t- poll() provides happens-before for element removal\n\t- Both offer identical visibility\n\t- peek() forces memory barriers\n\t- Only poll() reads volatile fields",
  "options": [
    "poll() ensures removal visibility",
    "Identical guarantees",
    "peek() has barriers",
    "poll() uses volatiles"
  ],
  "response": "poll() ensures removal visibility",
  "explanation": "Title: CLQ Memory Consistency\n\npoll()'s atomic removal establishes happens-before for subsequent operations, while peek() only reads.\n\nExample 1:\n// Producer\nqueue.offer(item); // write to volatile tail\n\nExample 2:\n// Consumer 1\nItem i = queue.peek(); // no removal\n\nExample 3:\n// Consumer 2\nItem j = queue.poll(); // CAS on head\n\nExample 4:\n// Internal node link\nvolatile Node<E> next;",
  "keywords": ["ConcurrentLinkedQueue", "poll", "peek", "memory barriers", "happens-before", "non-blocking", "CAS"]
},
    {
  "id": 5,
  "topic": "Legacy Synchronization",
  "question": "Why does Collections.synchronizedMap() exhibit poor throughput for entrySet() iteration under contention?\n\n\t- Requires global lock on entire map\n\t- Creates defensive copies of all entries\n\t- Uses fine-grained locking per entry\n\t- Lacks iterator fail-fast behavior",
  "options": [
    "Global lock during iteration",
    "Defensive copying",
    "Per-entry locking",
    "No fail-fast"
  ],
  "response": "Global lock during iteration",
  "explanation": "Title: SynchronizedMap Iteration Bottleneck\n\nSynchronizes on the entire map during iteration, blocking all other operations.\n\nExample 1:\nMap<String,Integer> m = Collections.synchronizedMap(...);\nfor (Entry<String,Integer> e : m.entrySet()) { ... } // Locks map\n\nExample 2:\n// Internal synchronization\npublic Set<Map.Entry<K,V>> entrySet() {\n  synchronized (mutex) { ... }\n\nExample 3:\n// Concurrent alternative\nConcurrentHashMap.KeySetView<K,V> ks = chm.keySet();",
  "keywords": ["synchronizedMap", "global lock", "entrySet", "contention", "throughput", "legacy", "iteration"]
},
    {
  "id": 4,
  "topic": "Sorted Concurrent Maps",
  "question": "What is the time complexity for ConcurrentSkipListMap's put() operation compared to ConcurrentHashMap?\n\n\t- O(log n) vs O(1) average case\n\t- O(1) vs O(n) worst case\n\t- Both O(1) with different constants\n\t- O(n) vs O(log n) for large datasets",
  "options": [
    "O(log n) vs O(1)",
    "O(1) vs O(n)",
    "Both O(1)",
    "O(n) vs O(log n)"
  ],
  "response": "O(log n) vs O(1)",
  "explanation": "Title: SkipList vs Hash Map Complexity\n\nSkipList provides sorted order at log(n) cost per operation, while CHM offers constant-time access.\n\nExample 1:\nConcurrentSkipListMap<Integer,String> sl = new ...\nsl.put(42, \"val\"); // Traverses skip levels\n\nExample 2:\nConcurrentHashMap<Integer,String> chm = new ...\nchm.put(42, \"val\"); // Hashes to bucket\n\nExample 3:\n// SkipList node structure\nstatic final class Node<K,V> {\n  final K key;\n  volatile Object value;\n  volatile Node<K,V> next;",
  "keywords": ["ConcurrentSkipListMap", "time complexity", "skip list", "logarithmic", "hashing", "sorted", "ConcurrentHashMap"]
},
    {
  "id": 3,
  "topic": "Blocking Queues",
  "question": "What memory visibility guarantees does LinkedBlockingQueue provide between producer and consumer threads?\n\n\t- Happens-before for items put before take\n\t- Only eventual consistency\n\t- Requires explicit synchronization\n\t- Visibility limited to queue size changes",
  "options": [
    "Happens-before for put/take pairs",
    "Eventual consistency",
    "Needs manual synchronization",
    "Size-only visibility"
  ],
  "response": "Happens-before for put/take pairs",
  "explanation": "Title: BlockingQueue Memory Model\n\nEstablishes happens-before between put() and subsequent take()/poll() calls via volatile fields and locks.\n\nExample 1:\n// Producer thread\nqueue.put(item); // write to volatile 'count'\n\nExample 2:\n// Consumer thread\nItem i = queue.take(); // read of volatile 'count'\n\nExample 3:\n// Internal lock visibility\nfinal ReentrantLock putLock = new ReentrantLock();",
  "keywords": ["BlockingQueue", "memory visibility", "happens-before", "volatile", "LinkedBlockingQueue", "producer-consumer", "ReentrantLock"]
},
    {
  "id": 2,
  "topic": "Fail-Safe Iterators",
  "question": "Why does CopyOnWriteArrayList's iterator never throw ConcurrentModificationException?\n\n\t- Uses a snapshot of the backing array\n\t- Implements deep cloning for each element\n\t- Synchronizes all iterator operations\n\t- Maintains a version counter for validation",
  "options": [
    "Iterates over array snapshot",
    "Deep cloning elements",
    "Synchronized iteration",
    "Version checking"
  ],
  "response": "Iterates over array snapshot",
  "explanation": "Title: CopyOnWrite Iterator Guarantees\n\nCreates immutable snapshot of array at iterator creation time, isolating from subsequent modifications.\n\nExample 1:\nCopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\nlist.add(\"A\");\nIterator<String> it = list.iterator();\nlist.add(\"B\");\nit.forEachRemaining(System.out::print); // Prints \"A\" only\n\nExample 2:\n// Backing array reference\nfinal transient Object[] elements; // Snapshot when iterator created\n\nExample 3:\n// Modification creates new array\npublic boolean add(E e) {\n  Object[] newElements = Arrays.copyOf(elements, len + 1);",
  "keywords": ["CopyOnWriteArrayList", "fail-safe", "iterator", "snapshot", "ConcurrentModificationException", "immutable", "backing array"]
},
    {
  "id": 1,
  "topic": "Concurrent Collections",
  "question": "In Java 8+, how does ConcurrentHashMap's internal segmentation differ from pre-Java 8 implementations?\n\n\t- Uses synchronized blocks per bucket instead of ReentrantLocks\n\t- Replaces segments with fine-grained node-level locking\n\t- Implements a global lock for all write operations\n\t- Removes synchronization entirely for read operations",
  "options": [
    "Node-level locking instead of segments",
    "Global lock for writes",
    "Unlocked reads",
    "Double-locking per operation"
  ],
  "response": "Node-level locking instead of segments",
  "explanation": "Title: ConcurrentHashMap Modernization\n\nJava 8+ replaces segment locks with CAS+synchronized per hash bucket node, improving throughput.\n\nExample 1:\n// Java 7: Segment array\nfinal Segment<K,V>[] segments;\n\nExample 2:\n// Java 8+: Node array\ntransient volatile Node<K,V>[] table;\n\nExample 3:\n// Java 17: Further optimized\nstatic class Node<K,V> implements Map.Entry<K,V> {\n  final int hash;\n  final K key;\n  volatile V val;\n  volatile Node<K,V> next;",
  "keywords": ["ConcurrentHashMap", "segmentation", "Java 8", "node locking", "CAS", "throughput", "bucket"]
},
    {
  "id": 10,
  "topic": "Local Variable Types",
  "question": "What is the compile-time type of `var list = Arrays.asList(1, 2.0)` in Java 10+?\n\n\t- `List<Integer>`\n\t- `List<Number>`\n\t- `List<Object>`\n\t- `List<Double>`",
  "options": [
    "List<Number>",
    "List<Integer>",
    "List<Serializable>",
    "List<Comparable>"
  ],
  "response": "List<Number>",
  "explanation": "Title: `var` and Generic Inference\n\n`var` inherits the most specific common supertype (Number for Integer and Double).\n\nExample 1:\nvar list = Arrays.asList(1, 2.0); // List<Number>\n\nExample 2:\nvar mixed = Arrays.asList(\"text\", 42); // List<Serializable & Comparable>\n\nExample 3:\n// Explicit type needed for clarity\nList<Number> nums = Arrays.asList(1, 2.0);",
  "keywords": ["var", "type inference", "generics", "common supertype", "Java 10", "local variables", "compile-time type"]
},
    {
  "id": 9,
  "topic": "Primitive Types",
  "question": "How does the JVM represent `boolean` values in memory at runtime?\n\n\t- As 1-bit flags\n\t- Using full bytes\n\t- Depends on JVM implementation\n\t- Always as integer 0/1",
  "options": [
    "JVM-dependent",
    "1-bit storage",
    "Always 4 bytes",
    "As Strings"
  ],
  "response": "JVM-dependent",
  "explanation": "Title: Boolean Storage Variability\n\nThe JVM spec doesn't mandate a size—HotSpot uses 1 byte per boolean, but arrays may pack them.\n\nExample 1:\nboolean b = true; // Typically 1 byte\n\nExample 2:\nboolean[] arr = new boolean[100]; // May use 1 bit per element\n\nExample 3:\n// JNI interaction\nnative void setFlag(boolean flag); // JVM-dependent ABI",
  "keywords": ["boolean", "JVM implementation", "memory layout", "primitive types", "HotSpot", "bit packing", "JNI"]
},
    {
  "id": 8,
  "topic": "Character Encoding",
  "question": "Why can't Java `char` type represent all Unicode characters despite using UTF-16?\n\n\t- Some codepoints require surrogate pairs\n\t- JVM uses ASCII internally\n\t- `char` is only 8-bit\n\t- Unicode standards prohibit it",
  "options": [
    "Surrogate pairs needed",
    "8-bit limitation",
    "ASCII restriction",
    "Hardware dependency"
  ],
  "response": "Surrogate pairs needed",
  "explanation": "Title: Unicode Character Representation\n\nUTF-16 uses 2 `char`s (surrogate pairs) for codepoints beyond BMP (Basic Multilingual Plane).\n\nExample 1:\nchar c = '𝄞'; // Compile error (U+1D11E needs 2 chars)\n\nExample 2:\n// Correct representation\nString s = \"𝄞\"; // Length=2 (surrogate pair)\n\nExample 3:\n// Codepoint handling\nint cp = s.codePointAt(0); // Returns 0x1D11E",
  "keywords": ["char", "UTF-16", "Unicode", "surrogate pairs", "codepoint", "BMP", "String"]
},
    {
  "id": 7,
  "topic": "Large Number Handling",
  "question": "What is the performance implication of `BigInteger`'s immutability for repeated arithmetic operations?\n\n\t- Requires object recreation\n\t- Enables thread safety\n\t- Allows JIT optimizations\n\t- Reduces garbage collection",
  "options": [
    "New objects per operation",
    "Faster than primitives",
    "Automatic memoization",
    "Stack allocation"
  ],
  "response": "New objects per operation",
  "explanation": "Title: BigInteger Operation Costs\n\nEach arithmetic operation returns a new object, increasing GC pressure for iterative calculations.\n\nExample 1:\nBigInteger x = BigInteger.ONE;\nfor (int i = 0; i < 100; i++) x = x.add(BigInteger.ONE); // 100 new objects\n\nExample 2:\n// Mutable alternative (third-party libs)\nMutableBigInteger y = new MutableBigInteger(1);\ny.add(1); // In-place modification\n\nExample 3:\n// Caching common values\nBigInteger.ZERO; // Reused instance",
  "keywords": ["BigInteger", "immutability", "performance", "object creation", "garbage collection", "arbitrary precision", "mutable alternative"]
},
    {
  "id": 6,
  "topic": "Enum Types",
  "question": "Why do enums consume more memory than integer constants despite similar functionality?\n\n\t- Each value is a full object\n\t- JVM stores metadata for reflection\n\t- Requires additional hash tables\n\t- All enum values are strings internally",
  "options": [
    "Full object overhead",
    "String conversion cost",
    "Slower comparison speed",
    "No garbage collection"
  ],
  "response": "Full object overhead",
  "explanation": "Title: Enum Memory Characteristics\n\nEach enum constant is an object with class metadata, ordinal tracking, and name storage.\n\nExample 1:\nenum Color { RED, GREEN }\n// Equivalent to 2 objects + class metadata\n\nExample 2:\n// Alternative: int constants\npublic static final int RED = 0;\n\nExample 3:\n// Memory comparison\nSystem.out.println(Color.RED instanceof Object); // true",
  "keywords": ["enum", "memory footprint", "object overhead", "constants", "ordinal", "reflection", "JVM metadata"]
},
    {
  "id": 5,
  "topic": "Advanced Data Types",
  "question": "How can varargs methods cause heap pollution warnings with generic types?\n\n\t- By forcing type erasure\n\t- Allowing non-reifiable types in arrays\n\t- Disabling JIT optimizations\n\t- Requiring explicit type parameters",
  "options": [
    "Non-reifiable type arrays",
    "Compiler bugs",
    "Stack overflow",
    "Incorrect method overloading"
  ],
  "response": "Non-reifiable type arrays",
  "explanation": "Title: Varargs and Generics Risks\n\nVarargs creates arrays of non-reifiable generic types, risking ClassCastException at runtime.\n\nExample 1:\nvoid unsafe(List<String>... lists) {}\n// Warning: Possible heap pollution\n\nExample 2:\n// Safe alternative\n@SafeVarargs\nfinal void safe(List<String>... lists) {}\n\nExample 3:\n// Runtime failure\nList<String>[] array = new List<String>[1]; // Compile error",
  "keywords": ["varargs", "heap pollution", "generics", "type erasure", "reifiable types", "@SafeVarargs", "arrays"]
},
    {
  "id": 4,
  "topic": "Wrapper Classes",
  "question": "What causes a `NullPointerException` when unboxing an `Integer` to `int`?\n\n\t- Automatic type conversion failure\n\t- Null value in Integer object\n\t- Arithmetic overflow\n\t- Compiler optimization bug",
  "options": [
    "Null Integer value",
    "Type mismatch",
    "Memory leak",
    "Thread interference"
  ],
  "response": "Null Integer value",
  "explanation": "Title: Autoboxing Null Hazards\n\nUnboxing `null` Integer to primitive `int` throws NPE because primitives cannot be null.\n\nExample 1:\nInteger num = null;\nint n = num; // NPE\n\nExample 2:\n// Safe unboxing\nint n = (num != null) ? num : 0;\n\nExample 3:\n// Map with potential null values\nMap<String, Integer> map = new HashMap<>();\nint val = map.get(\"missing\"); // NPE",
  "keywords": ["autoboxing", "NullPointerException", "wrapper class", "primitive", "null check", "unboxing", "default value"]
},
    {
  "id": 3,
  "topic": "Numeric Types",
  "question": "What is the output of `System.out.println(0.1 + 0.2 == 0.3)` and why?\n\n\t- `true` due to exact binary representation\n\t- `false` because of floating-point rounding\n\t- Compile error\n\t- Depends on JVM implementation",
  "options": [
    "`false` (rounding errors)",
    "`true` (exact math)",
    "Runtime exception",
    "`null`"
  ],
  "response": "`false` (rounding errors)",
  "explanation": "Title: Floating-Point Precision Limits\n\nBinary floating-point cannot precisely represent decimal fractions like 0.1, causing rounding errors in arithmetic.\n\nExample 1:\nSystem.out.println(0.1 + 0.2); // Prints 0.30000000000000004\n\nExample 2:\n// Solution: BigDecimal\nBigDecimal sum = new BigDecimal(\"0.1\").add(new BigDecimal(\"0.2\"));\n\nExample 3:\n// Integer workaround\nint cents = 10 + 20; // 30 cents = $0.30 exactly",
  "keywords": ["floating-point", "precision", "rounding error", "BigDecimal", "binary representation", "arithmetic", "IEEE 754"]
},
    {
  "id": 2,
  "topic": "String Handling",
  "question": "Why does concatenating strings in a loop with `+` operator degrade performance?\n\n\t- Creates intermediate String objects\n\t- JVM optimizes it automatically\n\t- Uses constant pool efficiently\n\t- No performance impact in modern Java",
  "options": [
    "Generates temporary objects",
    "Uses StringBuffer internally",
    "Compile-time optimization",
    "Works identically to StringBuilder"
  ],
  "response": "Generates temporary objects",
  "explanation": "Title: String Concatenation Overhead\n\nEach `+` operation creates a new String object, causing O(n²) time complexity for loops due to copying.\n\nExample 1:\nString s = \"\";\nfor (int i = 0; i < 100; i++) s += i; // 100 new objects\n\nExample 2:\n// Efficient alternative\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 100; i++) sb.append(i);\n\nExample 3:\n// Compile-time optimization (literal concatenation)\nString s = \"a\" + \"b\"; // Becomes \"ab\" at compile time",
  "keywords": ["String immutability", "concatenation", "StringBuilder", "performance", "temporary objects", "loop optimization", "constant pool"]
},
    {
  "id": 1,
  "topic": "Data Types Fundamentals",
  "question": "What is the key difference in memory usage between `int` and `Integer` when stored in an `ArrayList`?\n\n\t- Primitive `int` uses stack memory\n\t- `Integer` objects are heap-allocated\n\t- Autoboxing overhead occurs with `Integer`\n\t- Both behave identically in collections",
  "options": [
    "`Integer` causes heap allocation",
    "`int` is faster for iteration",
    "No difference in memory",
    "`Integer` uses less memory"
  ],
  "response": "`Integer` causes heap allocation",
  "explanation": "Title: Memory Impact of Wrapper Classes\n\nPrimitives like `int` use stack memory, while `Integer` objects require heap allocation, increasing GC pressure and memory overhead.\n\nExample 1:\nArrayList<Integer> list = new ArrayList<>();\nlist.add(42); // Heap allocation for Integer.valueOf(42)\n\nExample 2:\nint[] arr = new int[1000]; // Contiguous stack memory\n\nExample 3:\n// Autoboxing overhead\nfor (int i = 0; i < 1000; i++) list.add(i); // 1000 Integer objects",
  "keywords": ["primitive", "wrapper class", "heap allocation", "autoboxing", "memory overhead", "ArrayList", "stack memory"]
},
    {
  "id": 10,
  "topic": "Local Variable Types",
  "question": "What is the compile-time type of `var list = Arrays.asList(1, 2.0)` in Java 10+?\n\n\t- `List<Integer>`\n\t- `List<Number>`\n\t- `List<Object>`\n\t- `List<Double>`",
  "options": [
    "List<Number>",
    "List<Integer>",
    "List<Serializable>",
    "List<Comparable>"
  ],
  "response": "List<Number>",
  "explanation": "Title: `var` and Generic Inference\n\n`var` inherits the most specific common supertype (Number for Integer and Double).\n\nExample 1:\nvar list = Arrays.asList(1, 2.0); // List<Number>\n\nExample 2:\nvar mixed = Arrays.asList(\"text\", 42); // List<Serializable & Comparable>\n\nExample 3:\n// Explicit type needed for clarity\nList<Number> nums = Arrays.asList(1, 2.0);",
  "keywords": ["var", "type inference", "generics", "common supertype", "Java 10", "local variables", "compile-time type"]
},
    {
  "id": 9,
  "topic": "Primitive Types",
  "question": "How does the JVM represent `boolean` values in memory at runtime?\n\n\t- As 1-bit flags\n\t- Using full bytes\n\t- Depends on JVM implementation\n\t- Always as integer 0/1",
  "options": [
    "JVM-dependent",
    "1-bit storage",
    "Always 4 bytes",
    "As Strings"
  ],
  "response": "JVM-dependent",
  "explanation": "Title: Boolean Storage Variability\n\nThe JVM spec doesn't mandate a size—HotSpot uses 1 byte per boolean, but arrays may pack them.\n\nExample 1:\nboolean b = true; // Typically 1 byte\n\nExample 2:\nboolean[] arr = new boolean[100]; // May use 1 bit per element\n\nExample 3:\n// JNI interaction\nnative void setFlag(boolean flag); // JVM-dependent ABI",
  "keywords": ["boolean", "JVM implementation", "memory layout", "primitive types", "HotSpot", "bit packing", "JNI"]
},
    {
  "id": 8,
  "topic": "Character Encoding",
  "question": "Why can't Java `char` type represent all Unicode characters despite using UTF-16?\n\n\t- Some codepoints require surrogate pairs\n\t- JVM uses ASCII internally\n\t- `char` is only 8-bit\n\t- Unicode standards prohibit it",
  "options": [
    "Surrogate pairs needed",
    "8-bit limitation",
    "ASCII restriction",
    "Hardware dependency"
  ],
  "response": "Surrogate pairs needed",
  "explanation": "Title: Unicode Character Representation\n\nUTF-16 uses 2 `char`s (surrogate pairs) for codepoints beyond BMP (Basic Multilingual Plane).\n\nExample 1:\nchar c = '𝄞'; // Compile error (U+1D11E needs 2 chars)\n\nExample 2:\n// Correct representation\nString s = \"𝄞\"; // Length=2 (surrogate pair)\n\nExample 3:\n// Codepoint handling\nint cp = s.codePointAt(0); // Returns 0x1D11E",
  "keywords": ["char", "UTF-16", "Unicode", "surrogate pairs", "codepoint", "BMP", "String"]
},
    {
  "id": 7,
  "topic": "Large Number Handling",
  "question": "What is the performance implication of `BigInteger`'s immutability for repeated arithmetic operations?\n\n\t- Requires object recreation\n\t- Enables thread safety\n\t- Allows JIT optimizations\n\t- Reduces garbage collection",
  "options": [
    "New objects per operation",
    "Faster than primitives",
    "Automatic memoization",
    "Stack allocation"
  ],
  "response": "New objects per operation",
  "explanation": "Title: BigInteger Operation Costs\n\nEach arithmetic operation returns a new object, increasing GC pressure for iterative calculations.\n\nExample 1:\nBigInteger x = BigInteger.ONE;\nfor (int i = 0; i < 100; i++) x = x.add(BigInteger.ONE); // 100 new objects\n\nExample 2:\n// Mutable alternative (third-party libs)\nMutableBigInteger y = new MutableBigInteger(1);\ny.add(1); // In-place modification\n\nExample 3:\n// Caching common values\nBigInteger.ZERO; // Reused instance",
  "keywords": ["BigInteger", "immutability", "performance", "object creation", "garbage collection", "arbitrary precision", "mutable alternative"]
},
    {
  "id": 6,
  "topic": "Enum Types",
  "question": "Why do enums consume more memory than integer constants despite similar functionality?\n\n\t- Each value is a full object\n\t- JVM stores metadata for reflection\n\t- Requires additional hash tables\n\t- All enum values are strings internally",
  "options": [
    "Full object overhead",
    "String conversion cost",
    "Slower comparison speed",
    "No garbage collection"
  ],
  "response": "Full object overhead",
  "explanation": "Title: Enum Memory Characteristics\n\nEach enum constant is an object with class metadata, ordinal tracking, and name storage.\n\nExample 1:\nenum Color { RED, GREEN }\n// Equivalent to 2 objects + class metadata\n\nExample 2:\n// Alternative: int constants\npublic static final int RED = 0;\n\nExample 3:\n// Memory comparison\nSystem.out.println(Color.RED instanceof Object); // true",
  "keywords": ["enum", "memory footprint", "object overhead", "constants", "ordinal", "reflection", "JVM metadata"]
},
    {
  "id": 5,
  "topic": "Advanced Data Types",
  "question": "How can varargs methods cause heap pollution warnings with generic types?\n\n\t- By forcing type erasure\n\t- Allowing non-reifiable types in arrays\n\t- Disabling JIT optimizations\n\t- Requiring explicit type parameters",
  "options": [
    "Non-reifiable type arrays",
    "Compiler bugs",
    "Stack overflow",
    "Incorrect method overloading"
  ],
  "response": "Non-reifiable type arrays",
  "explanation": "Title: Varargs and Generics Risks\n\nVarargs creates arrays of non-reifiable generic types, risking ClassCastException at runtime.\n\nExample 1:\nvoid unsafe(List<String>... lists) {}\n// Warning: Possible heap pollution\n\nExample 2:\n// Safe alternative\n@SafeVarargs\nfinal void safe(List<String>... lists) {}\n\nExample 3:\n// Runtime failure\nList<String>[] array = new List<String>[1]; // Compile error",
  "keywords": ["varargs", "heap pollution", "generics", "type erasure", "reifiable types", "@SafeVarargs", "arrays"]
},
    {
  "id": 4,
  "topic": "Wrapper Classes",
  "question": "What causes a `NullPointerException` when unboxing an `Integer` to `int`?\n\n\t- Automatic type conversion failure\n\t- Null value in Integer object\n\t- Arithmetic overflow\n\t- Compiler optimization bug",
  "options": [
    "Null Integer value",
    "Type mismatch",
    "Memory leak",
    "Thread interference"
  ],
  "response": "Null Integer value",
  "explanation": "Title: Autoboxing Null Hazards\n\nUnboxing `null` Integer to primitive `int` throws NPE because primitives cannot be null.\n\nExample 1:\nInteger num = null;\nint n = num; // NPE\n\nExample 2:\n// Safe unboxing\nint n = (num != null) ? num : 0;\n\nExample 3:\n// Map with potential null values\nMap<String, Integer> map = new HashMap<>();\nint val = map.get(\"missing\"); // NPE",
  "keywords": ["autoboxing", "NullPointerException", "wrapper class", "primitive", "null check", "unboxing", "default value"]
},
    {
  "id": 3,
  "topic": "Numeric Types",
  "question": "What is the output of `System.out.println(0.1 + 0.2 == 0.3)` and why?\n\n\t- `true` due to exact binary representation\n\t- `false` because of floating-point rounding\n\t- Compile error\n\t- Depends on JVM implementation",
  "options": [
    "`false` (rounding errors)",
    "`true` (exact math)",
    "Runtime exception",
    "`null`"
  ],
  "response": "`false` (rounding errors)",
  "explanation": "Title: Floating-Point Precision Limits\n\nBinary floating-point cannot precisely represent decimal fractions like 0.1, causing rounding errors in arithmetic.\n\nExample 1:\nSystem.out.println(0.1 + 0.2); // Prints 0.30000000000000004\n\nExample 2:\n// Solution: BigDecimal\nBigDecimal sum = new BigDecimal(\"0.1\").add(new BigDecimal(\"0.2\"));\n\nExample 3:\n// Integer workaround\nint cents = 10 + 20; // 30 cents = $0.30 exactly",
  "keywords": ["floating-point", "precision", "rounding error", "BigDecimal", "binary representation", "arithmetic", "IEEE 754"]
},
    {
  "id": 2,
  "topic": "String Handling",
  "question": "Why does concatenating strings in a loop with `+` operator degrade performance?\n\n\t- Creates intermediate String objects\n\t- JVM optimizes it automatically\n\t- Uses constant pool efficiently\n\t- No performance impact in modern Java",
  "options": [
    "Generates temporary objects",
    "Uses StringBuffer internally",
    "Compile-time optimization",
    "Works identically to StringBuilder"
  ],
  "response": "Generates temporary objects",
  "explanation": "Title: String Concatenation Overhead\n\nEach `+` operation creates a new String object, causing O(n²) time complexity for loops due to copying.\n\nExample 1:\nString s = \"\";\nfor (int i = 0; i < 100; i++) s += i; // 100 new objects\n\nExample 2:\n// Efficient alternative\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 100; i++) sb.append(i);\n\nExample 3:\n// Compile-time optimization (literal concatenation)\nString s = \"a\" + \"b\"; // Becomes \"ab\" at compile time",
  "keywords": ["String immutability", "concatenation", "StringBuilder", "performance", "temporary objects", "loop optimization", "constant pool"]
},
    {
  "id": 1,
  "topic": "Data Types Fundamentals",
  "question": "What is the key difference in memory usage between `int` and `Integer` when stored in an `ArrayList`?\n\n\t- Primitive `int` uses stack memory\n\t- `Integer` objects are heap-allocated\n\t- Autoboxing overhead occurs with `Integer`\n\t- Both behave identically in collections",
  "options": [
    "`Integer` causes heap allocation",
    "`int` is faster for iteration",
    "No difference in memory",
    "`Integer` uses less memory"
  ],
  "response": "`Integer` causes heap allocation",
  "explanation": "Title: Memory Impact of Wrapper Classes\n\nPrimitives like `int` use stack memory, while `Integer` objects require heap allocation, increasing GC pressure and memory overhead.\n\nExample 1:\nArrayList<Integer> list = new ArrayList<>();\nlist.add(42); // Heap allocation for Integer.valueOf(42)\n\nExample 2:\nint[] arr = new int[1000]; // Contiguous stack memory\n\nExample 3:\n// Autoboxing overhead\nfor (int i = 0; i < 1000; i++) list.add(i); // 1000 Integer objects",
  "keywords": ["primitive", "wrapper class", "heap allocation", "autoboxing", "memory overhead", "ArrayList", "stack memory"]
},
    {
  "id": 10,
  "topic": "Concurrency Strategies",
  "question": "What is the primary advantage of java.util.concurrent collections over synchronized wrappers?\n\nOptions:\nA) Lower contention via fine-grained locking\nB) Built-in transaction support\nC) Guaranteed deadlock avoidance\nD) All of the above\n\nCode:\nMap<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());\nConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();",
  "options": [
    "Lower contention via fine-grained locking",
    "Built-in transaction support",
    "Guaranteed deadlock avoidance",
    "All of the above"
  ],
  "response": "Lower contention via fine-grained locking",
  "explanation": "Title: Concurrent Collection Benefits\n\njava.util.concurrent uses lock striping (e.g., CHM), CAS operations, or copy-on-write for higher throughput under contention vs. global locks.\n\nExample 1:\n// High contention (synchronizedMap)\nsyncMap.get(k); // Blocks all other operations\n\nExample 2:\n// Lower contention (CHM)\nconcurrentMap.get(k); // Non-blocking\n\nExample 3:\n// Write performance\nconcurrentMap.put(k, v); // Locks only one bucket",
  "keywords": ["java.util.concurrent", "fine-grained locking", "lock striping", "synchronizedMap", "ConcurrentHashMap", "throughput", "contention"]
},
    {
  "id": 9,
  "topic": "Specialized Collections",
  "question": "When does WeakHashMap automatically remove entries?\n\nOptions:\nA) When the key is garbage collected\nB) When the value is garbage collected\nC) After a timeout\nD) During full GC only\n\nCode:\nWeakHashMap<Key, Value> map = new WeakHashMap<>();\nmap.put(new Key(), new Value());\nSystem.gc(); // Key becomes eligible for GC",
  "options": [
    "When the key is garbage collected",
    "When the value is garbage collected",
    "After a timeout",
    "During full GC only"
  ],
  "response": "When the key is garbage collected",
  "explanation": "Title: WeakHashMap Entry Cleanup\n\nWeakHashMap holds weak references to keys, allowing entry removal when keys are GC'd. Values are strongly referenced until then.\n\nExample 1:\n// Entry removed after key GC\nKey k = new Key();\nmap.put(k, new Value());\nk = null; // Eligible for GC\nSystem.gc(); // Entry removed\n\nExample 2:\n// Strong value reference\nValue v = new Value();\nmap.put(new Key(), v); // Entry keeps v reachable\n\nExample 3:\n// Alternative: WeakReference<Value>\nMap<Key, WeakReference<Value>> weakValueMap = new HashMap<>();",
  "keywords": ["WeakHashMap", "weak references", "garbage collection", "entry cleanup", "memory management", "cache", "HashMap alternative"]
},
    {
  "id": 8,
  "topic": "Fail-Fast Iterators",
  "question": "How can a single-threaded application trigger ConcurrentModificationException with an ArrayList?\n\nOptions:\nA) Using remove() during iteration\nB) Calling size() during iteration\nC) Using parallelStream()\nD) All of the above\n\nCode:\nList<String> list = new ArrayList<>(List.of(\"A\", \"B\"));\nfor (String s : list) {\n  list.remove(s); // Throws CME\n}",
  "options": [
    "Using remove() during iteration",
    "Calling size() during iteration",
    "Using parallelStream()",
    "All of the above"
  ],
  "response": "Using remove() during iteration",
  "explanation": "Title: Fail-Fast Iteration Mechanics\n\nFail-fast iterators throw CME when detecting structural modifications (add/remove) during iteration, even in single-threaded code.\n\nExample 1:\n// Direct removal (CME)\nfor (String s : list) list.remove(s);\n\nExample 2:\n// Safe removal with iterator\nIterator<String> it = list.iterator();\nwhile (it.hasNext()) it.remove();\n\nExample 3:\n// No CME (but still unsafe)\nlist.parallelStream().forEach(list::remove); // May throw CME or corrupt data",
  "keywords": ["ConcurrentModificationException", "fail-fast iterator", "ArrayList", "structural modification", "single-threaded", "iterator.remove()", "parallelStream"]
},
    {
  "id": 7,
  "topic": "Legacy Synchronized Collections",
  "question": "What distinguishes Vector from Collections.synchronizedList(new ArrayList<>())?\n\nOptions:\nA) Vector synchronizes per method\nB) Vector has dynamic growth\nC) Vector is thread-safe\nD) Nothing, they are equivalent\n\nCode:\nVector<String> vec = new Vector<>();\nList<String> syncList = Collections.synchronizedList(new ArrayList<>());",
  "options": [
    "Vector synchronizes per method",
    "Vector has dynamic growth",
    "Vector is thread-safe",
    "Nothing, they are equivalent"
  ],
  "response": "Nothing, they are equivalent",
  "explanation": "Title: Vector vs. SynchronizedList\n\nBoth synchronize all methods and grow dynamically. Vector is legacy; synchronizedList is more flexible for wrapping other List implementations.\n\nExample 1:\n// Vector\nvec.add(\"A\"); // Synchronized\n\nExample 2:\n// SynchronizedList\nsyncList.add(\"A\"); // Also synchronized\n\nExample 3:\n// Flexibility advantage\nList<String> syncLinkedList = Collections.synchronizedList(new LinkedList<>());",
  "keywords": ["Vector", "synchronizedList", "legacy collections", "thread-safe list", "method synchronization", "dynamic growth", "ArrayList"]
}
    ,
    {
  "id": 6,
  "topic": "Concurrent Collections",
  "question": "When is ConcurrentSkipListMap preferable over ConcurrentHashMap?\n\nOptions:\nA) When requiring natural ordering\nB) For higher write throughput\nC) For better memory efficiency\nD) When needing null values\n\nCode:\nConcurrentSkipListMap<String, Integer> sortedMap = new ConcurrentSkipListMap<>();\nsortedMap.put(\"z\", 1);\nsortedMap.put(\"a\", 2);",
  "options": [
    "When requiring natural ordering",
    "For higher write throughput",
    "For better memory efficiency",
    "When needing null values"
  ],
  "response": "When requiring natural ordering",
  "explanation": "Title: Sorted Concurrent Maps\n\nConcurrentSkipListMap provides thread-safe sorting but has higher overhead than CHM. CHM is faster but unordered.\n\nExample 1:\n// Sorted iteration\nfor (Map.Entry<String, Integer> e : sortedMap.entrySet()) { ... } // a=2, z=1\n\nExample 2:\n// Unordered but faster\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\nmap.put(\"z\", 1); map.put(\"a\", 2);\n\nExample 3:\n// Null restriction\nmap.put(null, 1); // Throws NPE in both",
  "keywords": ["ConcurrentSkipListMap", "natural ordering", "sorted map", "ConcurrentHashMap", "thread-safe sorting", "skip list", "performance trade-off"]
},
    {
  "id": 5,
  "topic": "Synchronized Collections",
  "question": "What operation on a synchronizedMap is NOT thread-safe without external synchronization?\n\nOptions:\nA) map.put()\nB) map.get()\nC) map.containsKey() + map.putIfAbsent()\nD) map.size()\n\nCode:\nMap<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());\nif (!syncMap.containsKey(\"k\")) {\n  syncMap.put(\"k\", 1); // Race condition\n}",
  "options": [
    "map.put()",
    "map.get()",
    "map.containsKey() + map.putIfAbsent()",
    "map.size()"
  ],
  "response": "map.containsKey() + map.putIfAbsent()",
  "explanation": "Title: Compound Operation Race Conditions\n\nIndividual methods are thread-safe, but sequences like check-then-act require external synchronization to remain atomic.\n\nExample 1:\n// Race condition\nif (!map.containsKey(k)) map.put(k, v);\n\nExample 2:\n// Thread-safe single operation\nmap.put(k, v); // Atomic\n\nExample 3:\n// Proper synchronization\nsynchronized (map) {\n  if (!map.containsKey(k)) map.put(k, v);\n}",
  "keywords": ["synchronizedMap", "race condition", "compound operations", "check-then-act", "thread-safe", "atomicity", "external synchronization"]
},
    {
  "id": 4,
  "topic": "Blocking Collections",
  "question": "Which BlockingQueue implementation is optimal for a producer-consumer system with backpressure handling?\n\nOptions:\nA) LinkedBlockingQueue\nB) ArrayBlockingQueue\nC) SynchronousQueue\nD) PriorityBlockingQueue\n\nCode:\nBlockingQueue<Task> queue = new ArrayBlockingQueue<>(100);\n// Producer:\nqueue.put(task); // Blocks if full\n// Consumer:\nTask t = queue.take();",
  "options": [
    "LinkedBlockingQueue",
    "ArrayBlockingQueue",
    "SynchronousQueue",
    "PriorityBlockingQueue"
  ],
  "response": "ArrayBlockingQueue",
  "explanation": "Title: Backpressure with BlockingQueue\n\nArrayBlockingQueue's fixed size enforces backpressure (producers block when full). LinkedBlockingQueue may grow unbounded, risking OOM.\n\nExample 1:\n// Unbounded risk (LinkedBlockingQueue)\nnew LinkedBlockingQueue<>(); // May grow indefinitely\n\nExample 2:\n// Bounded (ArrayBlockingQueue)\nnew ArrayBlockingQueue<>(100); // Safe backpressure\n\nExample 3:\n// Extreme (SynchronousQueue)\nnew SynchronousQueue(); // No buffering, direct handoff",
  "keywords": ["BlockingQueue", "backpressure", "ArrayBlockingQueue", "LinkedBlockingQueue", "producer-consumer", "bounded queue", "SynchronousQueue"]
},
    {
  "id": 3,
  "topic": "Non-Blocking Collections",
  "question": "When should CopyOnWriteArrayList be avoided despite its thread safety?\n\nOptions:\nA) Frequent write operations\nB) Large datasets\nC) Real-time latency requirements\nD) All of the above\n\nCode:\nCopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\nlist.add(1); // Creates a new internal array",
  "options": [
    "Frequent write operations",
    "Large datasets",
    "Real-time latency requirements",
    "All of the above"
  ],
  "response": "All of the above",
  "explanation": "Title: CopyOnWriteArrayList Trade-offs\n\nCOWAL copies the entire array on modification, causing high overhead for writes/large datasets and unpredictable latency spikes.\n\nExample 1:\n// Expensive write\nfor (int i = 0; i < 100_000; i++) list.add(i); // O(n) per operation\n\nExample 2:\n// Memory churn\nlist.set(0, 99); // Allocates new array\n\nExample 3:\n// Alternative for frequent writes:\nCollections.synchronizedList(new ArrayList<>());",
  "keywords": ["CopyOnWriteArrayList", "write overhead", "memory churn", "latency spikes", "thread-safe list", "concurrency trade-offs", "synchronizedList"]
},
    {
  "id": 2,
  "topic": "Concurrent Collections",
  "question": "What is the key advantage of ConcurrentHashMap over Hashtable in high-contention scenarios?\n\nOptions:\nA) Full table-level locking\nB) Segment-level locking\nC) Lock-free reads\nD) Built-in transaction support\n\nCode:\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\nmap.put(\"key\", 1);\nint value = map.get(\"key\");",
  "options": [
    "Full table-level locking",
    "Segment-level locking",
    "Lock-free reads",
    "Built-in transaction support"
  ],
  "response": "Lock-free reads",
  "explanation": "Title: ConcurrentHashMap Locking Strategy\n\nConcurrentHashMap allows concurrent reads without locking and uses fine-grained locks for writes. Hashtable locks the entire table for all operations.\n\nExample 1:\n// Hashtable (global lock)\nHashtable<String, Integer> ht = new Hashtable<>();\nht.get(\"k\"); // Blocks all other operations\n\nExample 2:\n// CHM (non-blocking read)\nmap.get(\"k\"); // No lock, reads proceed concurrently\n\nExample 3:\n// CHM write (segment lock)\nmap.put(\"k\", 2); // Only locks one bucket",
  "keywords": ["ConcurrentHashMap", "Hashtable", "lock-free reads", "segment-level locking", "high contention", "thread-safe map", "concurrency"]
},
    {
  "id": 1,
  "topic": "Synchronized Collections",
  "question": "Why does iterating over a synchronized list require explicit synchronization despite the list being thread-safe?\n\nOptions:\nA) To prevent ConcurrentModificationException\nB) To ensure atomic compound operations\nC) The iterator is not thread-safe\nD) All of the above\n\nCode:\nList<String> syncList = Collections.synchronizedList(new ArrayList<>());\n// Thread 1:\nsyncList.add(\"A\");\n// Thread 2:\nfor (String s : syncList) { ... }",
  "options": [
    "To prevent ConcurrentModificationException",
    "To ensure atomic compound operations",
    "The iterator is not thread-safe",
    "All of the above"
  ],
  "response": "All of the above",
  "explanation": "Title: Synchronized List Iterator Pitfalls\n\nSynchronized collections only protect individual methods, not iteration sequences. Concurrent modifications during iteration cause undefined behavior.\n\nExample 1:\n// Unsafe iteration (may throw ConcurrentModificationException)\nfor (String s : syncList) { ... }\n\nExample 2:\n// Safe iteration with explicit lock\nsynchronized (syncList) {\n  for (String s : syncList) { ... }\n}\n\nExample 3:\n// Alternative: Use CopyOnWriteArrayList\nCopyOnWriteArrayList<String> safeList = new CopyOnWriteArrayList<>();\nfor (String s : safeList) { ... } // Thread-safe",
  "keywords": ["synchronizedList", "iterator", "ConcurrentModificationException", "thread-safe iteration", "compound operations", "explicit synchronization", "CopyOnWriteArrayList"]
},
    {
  "id": 10,
  "topic": "Threads & Memory",
  "question": "How can `ThreadLocal` cause memory leaks in web applications?\n\nOptions:\nA) Thread reuse in pools\nB) Missing `remove()` calls\nC) Strong references to classes\nD) All of the above\n\nCode:\nThreadLocal<User> userContext = new ThreadLocal<>();\nuserContext.set(currentUser);",
  "options": [
    "Thread reuse in pools",
    "Missing `remove()` calls",
    "Strong references to classes",
    "All of the above"
  ],
  "response": "All of the above",
  "explanation": "Title: ThreadLocal Leak Risks\n\nThread pools reuse threads, retaining `ThreadLocal` values unless `remove()` is called.\nStrong references prevent GC of classloaders in containers.\n\nExample 1:\n// Leak in Tomcat\nuserContext.set(user); // Never removed\n\nExample 2:\n// Fix: Use try-finally\ntry {\n  userContext.set(user);\n  // ...\n} finally { userContext.remove(); }\n\nExample 3:\n// WeakReference alternative\nThreadLocal<WeakReference<User>> weakContext = new ThreadLocal<>();",
  "keywords": ["ThreadLocal", "memory leak", "thread pool", "remove()", "WeakReference", "classloader"]
},
    
{
  "id": 9,
  "topic": "JVM Optimization",
  "question": "Which method is most likely to be inlined by the JIT compiler?\n\nOptions:\nA) Large recursive method\nB) Small `private static` method\nC) Method with `synchronized` block\nD) Virtual method with multiple overrides\n\nCode:\nprivate static int add(int a, int b) { return a + b; }\nsynchronized void update() { ... }",
  "options": [
    "Large recursive method",
    "Small `private static` method",
    "Method with `synchronized` block",
    "Virtual method with multiple overrides"
  ],
  "response": "Small `private static` method",
  "explanation": "Title: JIT Inlining Criteria\n\nSmall, static/final methods are prime candidates for inlining.\n`sync`/virtual methods complicate inlining; recursion is limited by depth.\n\nExample 1:\n// Ideal for inlining\nprivate static int square(int x) { return x * x; }\n\nExample 2:\n// Not inlined (synchronized)\nsynchronized void increment() { counter++; }\n\nExample 3:\n// Virtual call (runtime decision)\nvoid process() { ... } // Overridden in subclasses",
  "keywords": ["JIT", "inlining", "optimization", "synchronized", "virtual method", "recursion"]
},
    {
  "id": 8,
  "topic": "Lists",
  "question": "Which list implementation is immutable and memory-efficient?\n\nOptions:\nA) `List.of()`\nB) `Arrays.asList()`\nC) `new ArrayList<>()`\nD) `Collections.emptyList()`\n\nCode:\nList<String> l1 = List.of(\"a\", \"b\");\nList<String> l2 = Arrays.asList(\"a\", \"b\");",
  "options": [
    "`List.of()`",
    "`Arrays.asList()`",
    "`new ArrayList<>()`",
    "`Collections.emptyList()`"
  ],
  "response": "`List.of()`",
  "explanation": "Title: Immutable List Implementations\n\n`List.of()` creates compact, immutable lists. `Arrays.asList()` is a mutable view of an array.\n`ArrayList` is mutable and heap-allocated.\n\nExample 1:\n// Immutable (Java 9+)\nList<String> l = List.of(\"a\", \"b\");\nl.add(\"c\"); // UnsupportedOperationException\n\nExample 2:\n// Mutable view\nList<String> l = Arrays.asList(\"a\", \"b\");\nl.set(0, \"c\"); // OK\n\nExample 3:\n// Memory overhead\nList<String> l = new ArrayList<>(List.of(\"a\", \"b\")); // 16-byte array + metadata",
  "keywords": ["List.of", "Arrays.asList", "immutable", "memory efficiency", "ArrayList", "UnsupportedOperationException"]
},
    {
  "id": 7,
  "topic": "Threads & Atomicity",
  "question": "When should `AtomicInteger` be preferred over `volatile int`?\n\nOptions:\nA) For read-heavy workloads\nB) For compound actions (e.g., `i++`)\nC) When memory visibility is sufficient\nD) Never\n\nCode:\nvolatile int counter1 = 0;\nAtomicInteger counter2 = new AtomicInteger(0);",
  "options": [
    "For read-heavy workloads",
    "For compound actions (e.g., `i++`)",
    "When memory visibility is sufficient",
    "Never"
  ],
  "response": "For compound actions (e.g., `i++`)",
  "explanation": "Title: Atomicity vs. Visibility\n\n`volatile` ensures visibility but not atomicity (e.g., `counter++` is non-atomic).\n`AtomicInteger` provides CAS-based atomic operations.\n\nExample 1:\n// Unsafe with volatile\ncounter1++; // Race condition\n\nExample 2:\n// Safe with AtomicInteger\ncounter2.incrementAndGet(); // Atomic\n\nExample 3:\n// Read-only (volatile is enough)\nif (counter1 > 0) { ... } // Safe for visibility",
  "keywords": ["volatile", "AtomicInteger", "CAS", "atomicity", "memory visibility", "race condition"]
},
    
{
  "id": 6,
  "topic": "Threads",
  "question": "What causes deadlock in a fixed-thread pool with nested tasks?\n\nOptions:\nA) Task dependency cycles\nB) Too few threads\nC) Unbounded queues\nD) All of the above\n\nCode:\nExecutorService pool = Executors.newFixedThreadPool(2);\npool.submit(() -> {\n  Future<?> f = pool.submit(() -> System.out.println(\"Nested\"));\n  f.get(); // Deadlock!\n});",
  "options": [
    "Task dependency cycles",
    "Too few threads",
    "Unbounded queues",
    "All of the above"
  ],
  "response": "All of the above",
  "explanation": "Title: Thread Pool Deadlock Risks\n\nDeadlock occurs if all threads wait for nested tasks (cycle) and the pool is undersized.\nUnbounded queues hide starvation but don’t prevent deadlock.\n\nExample 1:\n// Deadlock with 2 threads\npool.submit(() -> {\n  Future<?> f = pool.submit(() -> {});\n  f.get(); // Blocks forever\n});\n\nExample 2:\n// Fix: Use larger pool\nExecutorService pool = Executors.newFixedThreadPool(4);\n\nExample 3:\n// Fix: Avoid nested blocking\nCompletableFuture.supplyAsync(() -> {}, pool); // Non-blocking",
  "keywords": ["thread pool", "deadlock", "ExecutorService", "nested tasks", "starvation", "CompletableFuture"]
},
    {
  "id": 5,
  "topic": "JVM Memory",
  "question": "Which JVM flag controls the size of the G1 Heap regions?\n\nOptions:\nA) `-XX:G1HeapRegionSize`\nB) `-Xmn`\nC) `-XX:NewSize`\nD) `-XX:SurvivorRatio`\n\nCode:\n// JVM args for G1 GC\n// -XX:+UseG1GC -XX:G1HeapRegionSize=2M",
  "options": [
    "`-XX:G1HeapRegionSize`",
    "`-Xmn`",
    "`-XX:NewSize`",
    "`-XX:SurvivorRatio`"
  ],
  "response": "`-XX:G1HeapRegionSize`",
  "explanation": "Title: G1 Heap Region Configuration\n\n`-XX:G1HeapRegionSize` sets the size (1MB–32MB) of G1 regions.\n`-Xmn` sets young gen size; `SurvivorRatio` adjusts Eden/Survivor.\n\nExample 1:\n// 4MB regions (default is ergonomic)\n-XX:G1HeapRegionSize=4M\n\nExample 2:\n// Too small (overhead)\n-XX:G1HeapRegionSize=1M // May increase GC pauses\n\nExample 3:\n// Too large (waste)\n-XX:G1HeapRegionSize=32M // Poor heap utilization",
  "keywords": ["G1GC", "HeapRegionSize", "JVM flags", "memory regions", "GC tuning", "ergonomics"]
},
    {
  "id": 4,
  "topic": "Lists & Maps",
  "question": "How to safely iterate over a `ConcurrentHashMap` while another thread modifies it?\n\nOptions:\nA) `synchronized` block\nB) `Collections.unmodifiableMap()`\nC) CHM's `forEach()`\nD) Clone the map first\n\nCode:\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\nmap.put(\"a\", 1);\nmap.put(\"b\", 2);",
  "options": [
    "`synchronized` block",
    "`Collections.unmodifiableMap()`",
    "CHM's `forEach()`",
    "Clone the map first"
  ],
  "response": "CHM's `forEach()`",
  "explanation": "Title: Safe Iteration in ConcurrentHashMap\n\n`ConcurrentHashMap.forEach()` provides thread-safe traversal without locks.\nCloning/synchronization defeats CHM's purpose; `unmodifiableMap()` is a view, not thread-safe.\n\nExample 1:\n// Safe iteration\nmap.forEach((k, v) -> System.out.println(k + \": \" + v));\n\nExample 2:\n// Risky (ConcurrentModificationException possible)\nfor (Map.Entry<String, Integer> e : map.entrySet()) { ... }\n\nExample 3:\n// Overhead (unnecessary synchronization)\nsynchronized (map) {\n  map.forEach((k, v) -> { ... });\n}",
  "keywords": ["ConcurrentHashMap", "thread-safe", "forEach", "iteration", "synchronized", "concurrency"]
},
    
{
  "id": 3,
  "topic": "Data Types",
  "question": "Why does `ArrayList<Integer>` perform worse than `int[]` for large datasets?\n\nOptions:\nA) Boxing overhead\nB) Memory fragmentation\nC) Cache misses\nD) All of the above\n\nCode:\nList<Integer> list = new ArrayList<>();\nint[] arr = new int[1_000_000];",
  "options": [
    "Boxing overhead",
    "Memory fragmentation",
    "Cache misses",
    "All of the above"
  ],
  "response": "All of the above",
  "explanation": "Title: Primitive vs. Boxed Performance\n\n`ArrayList<Integer>` stores objects (heap allocation), causing boxing/unboxing overhead, memory fragmentation, and cache inefficiency.\n`int[]` uses contiguous primitive data.\n\nExample 1:\n// Boxing overhead\nlist.add(42); // Implicit Integer.valueOf(42)\nint x = list.get(0); // Implicit list.get(0).intValue()\n\nExample 2:\n// Memory access\nfor (int i : arr) { ... } // Contiguous memory\nfor (int i : list) { ... } // Pointer chasing\n\nExample 3:\n// Cache locality test\nArrays.fill(arr, 1); // Faster than\nlist.forEach(i -> list.set(i, 1));",
  "keywords": ["boxing", "primitive", "ArrayList", "performance", "cache", "memory fragmentation"]
},
    {
  "id": 2,
  "topic": "Vectors & SIMD",
  "question": "How can Java leverage SIMD instructions for vector operations?\n\nOptions:\nA) Using `java.util.Vector`\nB) Manual loop unrolling\nC) JVM's auto-vectorization\nD) `var handles` with `MethodHandles.lookup()`\n\nCode:\ndouble[] a = new double[1000];\ndouble[] b = new double[1000];\n// ... Initialize arrays ...",
  "options": [
    "Using `java.util.Vector`",
    "Manual loop unrolling",
    "JVM's auto-vectorization",
    "`var handles` with `MethodHandles.lookup()`"
  ],
  "response": "JVM's auto-vectorization",
  "explanation": "Title: SIMD Optimization in Java\n\nThe JVM auto-vectorizes simple loops (e.g., array sums) into SIMD instructions (SSE/AVX).\n`java.util.Vector` is a legacy collection, not related to CPU vectors.\n\nExample 1:\n// Auto-vectorized sum\ndouble sum = 0;\nfor (double v : a) sum += v; // JVM may use SIMD\n\nExample 2:\n// Manual unrolling (less reliable)\nfor (int i = 0; i < n; i += 4) {\n  sum += a[i] + a[i+1] + a[i+2] + a[i+3];\n}\n\nExample 3:\n// Incorrect approach (no SIMD)\nVector<Double> vec = new Vector<>(); // Legacy collection class",
  "keywords": ["SIMD", "vectorization", "JVM", "auto-vectorization", "loop unrolling", "AVX"]
},
    
{
  "id": 1,
  "topic": "Matrices & Performance",
  "question": "Which matrix multiplication approach is most cache-efficient for large matrices in Java?\n\nOptions:\nA) Naive triple-nested loop\nB) Transposing the second matrix first\nC) Using Java Streams\nD) Leveraging `Arrays.parallelSetAll`\n\nCode:\nint[][] A = new int[1000][1000];\nint[][] B = new int[1000][1000];\n// ... Initialize matrices ...",
  "options": [
    "Naive triple-nested loop",
    "Transposing the second matrix first",
    "Using Java Streams",
    "Leveraging `Arrays.parallelSetAll`"
  ],
  "response": "Transposing the second matrix first",
  "explanation": "Title: Cache-Efficient Matrix Multiplication\n\nTransposing the second matrix improves spatial locality by accessing contiguous memory.\nNaive loops cause cache misses due to row-column access patterns.\n\nExample 1:\n// Naive O(n³) approach\nfor (int i = 0; i < n; i++)\n  for (int j = 0; j < n; j++)\n    for (int k = 0; k < n; k++)\n      C[i][j] += A[i][k] * B[k][j]; // Poor cache performance\n\nExample 2:\n// Transposed B\nint[][] BT = transpose(B);\nfor (int i = 0; i < n; i++)\n  for (int j = 0; j < n; j++)\n    for (int k = 0; k < n; k++)\n      C[i][j] += A[i][k] * BT[j][k]; // Better cache hits\n\nExample 3:\n// Parallelized (but still inefficient without transposition)\nArrays.parallelSetAll(C, i -> {\n  for (int j = 0; j < n; j++)\n    for (int k = 0; k < n; k++)\n      C[i][j] += A[i][k] * B[k][j];\n  return C[i];\n});",
  "keywords": ["matrix", "cache efficiency", "transpose", "multiplication", "performance", "spatial locality"]
},
    {
      "id": 1,
      "topic": "Variables, Data Types, and Operators",
      "question": "What is the output of the following code?\n\nint x = 10;\ndouble y = 3.5;\ndouble z = x + y;\nSystem.out.println(z);",
      "options": ["13.5", "10", "3.5", "Compilation Error", "Runtime Error"],
      "response": "13.5",
      "explanation": "Java promotes the int to double before addition. So 10 + 3.5 results in 13.5.",
      "keywords": ["data types", "casting", "promotion", "double", "int", "variables", "operators", "addition", "Java", "output"]
    },
    {
      "id": 2,
      "topic": "Control Flow (if, switch, loops)",
      "question": "Which control flow statement is best suited for iterating over an array?",
      "options": ["if", "switch", "for", "break", "return"],
      "response": "for",
      "explanation": "`for` loops are ideal for iterating through arrays when the index is known.",
      "keywords": ["control flow", "loop", "for", "iteration", "arrays", "Java", "syntax", "statements", "conditions", "index"]
    },
    {
      "id": 3,
      "topic": "Arrays and Strings",
      "question": "What is the output?\n\nString s = \"Java\";\ns = s.concat(\" Programming\");\nSystem.out.println(s);",
      "options": ["Java", "Programming", "Java Programming", "concat error", "null"],
      "response": "Java Programming",
      "explanation": "String is immutable, and `concat()` returns a new string. The assignment updates `s`.",
      "keywords": ["strings", "concat", "immutable", "assignment", "Java", "output", "methods", "String class", "text", "reference"]
    },
    {
      "id": 4,
      "topic": "Methods and Functions",
      "question": "Which keyword is used to define a method that returns nothing in Java?",
      "options": ["method", "function", "def", "void", "fun"],
      "response": "void",
      "explanation": "`void` is used to define methods that return no value in Java.",
      "keywords": ["methods", "functions", "void", "return type", "definition", "Java", "syntax", "declaration", "parameters", "keyword"]
    },
    {
      "id": 5,
      "topic": "Classes, Objects, and OOP (Inheritance, Polymorphism, Encapsulation, Abstraction)",
      "question": "Which concept allows objects to take many forms?",
      "options": ["Inheritance", "Abstraction", "Encapsulation", "Polymorphism", "Overloading"],
      "response": "Polymorphism",
      "explanation": "Polymorphism enables a method to perform differently based on the object.",
      "keywords": ["OOP", "polymorphism", "inheritance", "dynamic binding", "objects", "Java", "abstraction", "override", "runtime", "behavior"]
    },
    {
      "id": 6,
      "topic": "Interfaces and Enums",
      "question": "Which statement correctly defines a Java interface?",
      "options": ["interface A {}", "class interface A {}", "public class A implements interface {}", "A interface {}", "def interface A"],
      "response": "interface A {}",
      "explanation": "Java uses the `interface` keyword to declare interfaces.",
      "keywords": ["interface", "Java", "keyword", "declaration", "abstraction", "OOP", "syntax", "implements", "contracts", "methods"]
    },
    {
      "id": 7,
      "topic": "Exception Handling",
      "question": "What is the base class for all exceptions in Java?",
      "options": ["Throwable", "Error", "Exception", "RuntimeException", "IOException"],
      "response": "Throwable",
      "explanation": "`Throwable` is the superclass of all exceptions and errors in Java.",
      "keywords": ["exceptions", "throwable", "error", "exception handling", "Java", "try-catch", "runtime", "hierarchy", "base class", "throw"]
    },
    {
      "id": 8,
      "topic": "Collections and Generics",
      "question": "Which collection maintains insertion order and allows duplicates?",
      "options": ["HashSet", "TreeSet", "ArrayList", "LinkedHashSet", "Map"],
      "response": "ArrayList",
      "explanation": "`ArrayList` maintains insertion order and allows duplicates.",
      "keywords": ["collections", "arraylist", "list", "duplicates", "order", "Java", "set", "hashset", "iterator", "structure"]
    },
    {
      "id": 9,
      "topic": "File I/O and Serialization",
      "question": "Which class is used to write text to a file in Java?",
      "options": ["Scanner", "FileWriter", "File", "FileInputStream", "ObjectOutputStream"],
      "response": "FileWriter",
      "explanation": "`FileWriter` writes character data to files.",
      "keywords": ["file", "filewriter", "write", "io", "java.io", "serialization", "output", "character stream", "Java", "files"]
    },
    {
      "id": 10,
      "topic": "Threads and Concurrency",
      "question": "Which method starts a thread in Java?",
      "options": ["run()", "init()", "execute()", "start()", "create()"],
      "response": "start()",
      "explanation": "`start()` launches a new thread and calls `run()` internally.",
      "keywords": ["thread", "start", "run", "concurrency", "multithreading", "Java", "asynchronous", "parallel", "runnable", "execution"]
    },
    {
      "id": 11,
      "topic": "Lambda Expressions and Functional Interfaces",
      "question": "Which statement defines a functional interface in Java?",
      "options": [
        "@FunctionalInterface\ninterface Converter<T, R> { R convert(T t); }",
        "interface Marker {}",
        "class Lambda {}",
        "@interface FunctionalInterface",
        "interface Predicate { boolean test(); void reset(); }"
      ],
      "response": "@FunctionalInterface\ninterface Converter<T, R> { R convert(T t); }",
      "explanation": "A functional interface contains only one abstract method. The @FunctionalInterface annotation is optional but recommended.",
      "keywords": ["lambda", "functional interface", "annotation", "Java 8", "single method", "SAM", "functional", "interface", "java.util.function", "syntax"]
    },
    {
      "id": 12,
      "topic": "Streams and Optional",
      "question": "What does this code print?\n\nOptional<String> opt = Optional.of(\"Java\");\nSystem.out.println(opt.orElse(\"Python\"));",
      "options": ["Java", "Python", "null", "Compilation Error", "Exception"],
      "response": "Java",
      "explanation": "Optional.of(\"Java\") is not empty, so orElse returns \"Java\" instead of the fallback.",
      "keywords": ["optional", "stream", "orElse", "null safe", "java.util", "optional chaining", "default value", "get", "presence", "container"]
    },
    {
      "id": 13,
      "topic": "Annotations and Reflection",
      "question": "Which class is used to analyze annotations at runtime?",
      "options": ["Annotation", "ReflectionUtils", "MethodHandles", "Class", "AnnotationProcessor"],
      "response": "Class",
      "explanation": "Java uses reflection via the Class object to inspect annotations using methods like getAnnotation() and isAnnotationPresent().",
      "keywords": ["reflection", "annotations", "metadata", "runtime", "Class", "getAnnotation", "java.lang.reflect", "introspection", "fields", "methods"]
    },
    {
      "id": 14,
      "topic": "Access Modifiers and Static/Final",
      "question": "What is the effect of marking a field `static final`?",
      "options": ["It can be changed later", "It belongs to instance", "It's shared and immutable", "It’s garbage collected", "None"],
      "response": "It's shared and immutable",
      "explanation": "`static` makes a field class-level, and `final` makes it immutable—together forming a constant shared across all instances.",
      "keywords": ["static", "final", "constant", "class field", "immutability", "shared", "memory", "Java", "modifiers", "access"]
    },
    {
      "id": 15,
      "topic": "Inner Classes",
      "question": "What is a non-static inner class called in Java?",
      "options": ["Nested class", "Local class", "Member class", "Anonymous class", "Abstract class"],
      "response": "Member class",
      "explanation": "A non-static inner class defined inside another class is called a member class and needs an outer instance.",
      "keywords": ["inner class", "member class", "nested", "Java", "non-static", "object", "enclosure", "scope", "local class", "class relationship"]
    },
    {
      "id": 16,
      "topic": "Packages, Imports, and Modules",
      "question": "What keyword is used to import a class from another package?",
      "options": ["include", "using", "import", "require", "load"],
      "response": "import",
      "explanation": "`import` allows classes from other packages to be referenced in your code.",
      "keywords": ["import", "packages", "modules", "Java", "namespace", "static import", "organization", "classpath", "syntax", "visibility"]
    },
    {
      "id": 17,
      "topic": "JVM, Memory Model, and Garbage Collection",
      "question": "Which part of memory is used to store class metadata in JVM?",
      "options": ["Heap", "Stack", "PermGen/MetaSpace", "Native Method Stack", "Registers"],
      "response": "PermGen/MetaSpace",
      "explanation": "Class metadata is stored in PermGen (Java 7 and earlier) or MetaSpace (Java 8+), separate from the heap.",
      "keywords": ["jvm", "memory", "metaspace", "permgen", "heap", "class metadata", "garbage collection", "Java", "runtime", "architecture"]
    },
    {
      "id": 18,
      "topic": "JDBC and Database Access",
      "question": "Which interface is used to execute SQL queries in JDBC?",
      "options": ["Connection", "Statement", "ResultSet", "DatabaseMetaData", "DriverManager"],
      "response": "Statement",
      "explanation": "The Statement interface sends SQL commands to the database, and results are retrieved via ResultSet.",
      "keywords": ["jdbc", "sql", "statement", "query", "Java", "database", "connection", "execute", "resultset", "driver"]
    },
    {
      "id": 19,
      "topic": "JUnit and Testing",
      "question": "Which JUnit annotation is used to run code before each test method?",
      "options": ["@BeforeAll", "@BeforeEach", "@Test", "@Init", "@Setup"],
      "response": "@BeforeEach",
      "explanation": "`@BeforeEach` is used in JUnit 5 to specify methods that run before every test method.",
      "keywords": ["junit", "testing", "annotations", "beforeeach", "setup", "Java", "test method", "test lifecycle", "unit test", "TDD"]
    },
    {
      "id": 20,
      "topic": "Java 8+ Features (Record, Pattern Matching, etc.)",
      "question": "Which statement correctly defines a Java Record?",
      "options": [
        "record Person(String name, int age) {}",
        "class Person(String name, int age) {}",
        "@Data class Person { String name; int age; }",
        "data class Person(String name, int age)",
        "val Person = Record.of(String, int)"
      ],
      "response": "record Person(String name, int age) {}",
      "explanation": "Records, introduced in Java 14+, are concise syntax for immutable data carriers using the `record` keyword.",
      "keywords": ["record", "java 14", "immutable", "data class", "constructor", "fields", "syntax", "accessor", "modern java", "lightweight"]
    },
    {
      "id": 21,
      "topic": "Lambda Expressions",
      "question": "What does this code print?\n\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nnames.forEach(name -> System.out.print(name + \" \"));",
      "options": ["Alice Bob Charlie", "Charlie Bob Alice", "Compilation Error", "Runtime Error", "Nothing"],
      "response": "Alice Bob Charlie",
      "explanation": "The lambda expression iterates over the list and prints each name in order.",
      "keywords": ["lambda", "list", "foreach", "java.util", "java 8", "functional", "stream", "print", "order", "syntax"]
    },
    {
      "id": 22,
      "topic": "Streams",
      "question": "What is the output?\n\nList<Integer> nums = Arrays.asList(1, 2, 3);\nint sum = nums.stream().mapToInt(i -> i * 2).sum();\nSystem.out.println(sum);",
      "options": ["6", "12", "3", "9", "Compilation Error"],
      "response": "12",
      "explanation": "Stream multiplies each number by 2: 2 + 4 + 6 = 12.",
      "keywords": ["stream", "map", "sum", "lambda", "java.util", "int", "iteration", "functional", "aggregation", "transform"]
    },
    {
      "id": 23,
      "topic": "Exception Handling",
      "question": "What happens when this code runs?\n\ntry {\n  int x = 5 / 0;\n} catch (ArithmeticException e) {\n  System.out.println(\"Error\");\n}",
      "options": ["Error", "0", "5", "Infinity", "Runtime Crash"],
      "response": "Error",
      "explanation": "Dividing by zero throws ArithmeticException, which is caught and handled.",
      "keywords": ["exception", "try catch", "division", "arithmetic", "error", "Java", "runtime", "handler", "crash", "zero"]
    },
    {
      "id": 24,
      "topic": "Inheritance",
      "question": "What is the output?\n\nclass A { void show() { System.out.println(\"A\"); } }\nclass B extends A { void show() { System.out.println(\"B\"); } }\n\nA obj = new B();\nobj.show();",
      "options": ["A", "B", "Compilation Error", "Runtime Error", "null"],
      "response": "B",
      "explanation": "Dynamic method dispatch resolves to class B's version of `show`.",
      "keywords": ["inheritance", "polymorphism", "override", "dynamic dispatch", "object", "Java", "method", "extends", "runtime", "OOP"]
    },
    {
      "id": 25,
      "topic": "File I/O",
      "question": "What does this write to file?\n\nFiles.write(Paths.get(\"test.txt\"), \"Hello\".getBytes());",
      "options": ["Writes 'Hello'", "Compilation Error", "Does nothing", "Writes byte size", "Creates empty file"],
      "response": "Writes 'Hello'",
      "explanation": "The `Files.write` method writes byte content to the given path.",
      "keywords": ["file io", "files", "write", "java.nio", "bytes", "path", "filesystem", "write", "output", "java"]
    },
    {
      "id": 26,
      "topic": "Multithreading",
      "question": "What does this thread print?\n\nnew Thread(() -> System.out.println(\"Hello from thread\")).start();",
      "options": ["Hello from thread", "Compilation Error", "Nothing", "Thread", "null"],
      "response": "Hello from thread",
      "explanation": "This lambda-based thread prints once when run asynchronously.",
      "keywords": ["thread", "lambda", "runnable", "Java", "start", "asynchronous", "multithreading", "execution", "print", "run"]
    },
    {
      "id": 27,
      "topic": "Switch Expressions",
      "question": "What does this output?\n\nint day = 2;\nswitch (day) {\n  case 1 -> System.out.println(\"Mon\");\n  case 2 -> System.out.println(\"Tue\");\n}",
      "options": ["Tue", "Mon", "Compilation Error", "null", "Crash"],
      "response": "Tue",
      "explanation": "Switch expressions introduced in Java 14 allow concise arrow-based cases.",
      "keywords": ["switch", "expression", "arrow", "java 14", "control", "flow", "statement", "case", "syntax", "print"]
    },
    {
      "id": 28,
      "topic": "Optional",
      "question": "What is the output?\n\nOptional<String> opt = Optional.empty();\nSystem.out.println(opt.orElse(\"default\"));",
      "options": ["default", "null", "Compilation Error", "Optional", "Empty"],
      "response": "default",
      "explanation": "`orElse()` returns fallback when the Optional is empty.",
      "keywords": ["optional", "java.util", "null", "safe", "default", "orElse", "empty", "container", "optional chaining", "fallback"]
    },
    {
      "id": 29,
      "topic": "Access Modifiers",
      "question": "Which access modifier allows visibility within the same package only?",
      "options": ["private", "public", "protected", "default", "static"],
      "response": "default",
      "explanation": "If no modifier is specified, Java assumes default (package-private) access.",
      "keywords": ["access", "modifier", "default", "visibility", "scope", "Java", "package", "protected", "private", "public"]
    },
    {
      "id": 30,
      "topic": "Generics",
      "question": "What does this print?\n\nList<String> list = new ArrayList<>();\nlist.add(\"Java\");\nSystem.out.println(list.get(0));",
      "options": ["Java", "0", "Compilation Error", "null", "String"],
      "response": "Java",
      "explanation": "Generics enforce type safety. get(0) returns the string added.",
      "keywords": ["generics", "collections", "list", "ArrayList", "type", "safety", "get", "add", "Java", "output"]
    },
    {
      "id": 31,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 31; int b = 4;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "3",
      "explanation": "The modulo (%) operator returns the remainder of division between two integers. In this case, `31 % 4` equals 3.\n\nExamples:\n1. `int a = 10, b = 3;` → Output: 1 (10 / 3 = 3 R1)\n2. `int a = 8, b = 2;` → Output: 0 (8 is divisible by 2)\n3. `int a = 7, b = 5;` → Output: 2 (7 / 5 = 1 R2)\n4. `int a = 15, b = 4;` → Output: 3 (15 / 4 = 3 R3)\n// Useful in hashing, loops, and buffer rotation.",
      "keywords": ["modulo", "arithmetic", "operators", "Java", "integer", "remainder", "division", "math", "interview", "syntax"]
    },
    {
      "id": 32,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 32; int b = 1;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "0",
      "explanation": "Any number modulo 1 returns 0, since there is no remainder.\n\nExamples:\n1. `int a = 5, b = 1;` → Output: 0\n2. `int a = 100, b = 1;` → Output: 0\n3. `int a = -10, b = 1;` → Output: 0\n4. `int a = 0, b = 1;` → Output: 0\n// Useful in fixed-size window computations.",
      "keywords": ["modulo", "division", "zero", "Java", "arithmetic", "integer", "remainder", "math", "syntax", "operators"]
    },
    {
      "id": 33,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 33; int b = 2;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "1",
      "explanation": "`33 % 2` returns 1 because 33 divided by 2 gives a remainder of 1.\n\nExamples:\n1. `int a = 9, b = 2;` → Output: 1\n2. `int a = 13, b = 2;` → Output: 1\n3. `int a = 4, b = 2;` → Output: 0\n4. `int a = 1, b = 2;` → Output: 1\n// Helpful in checking if a number is even or odd.",
      "keywords": ["modulo", "remainder", "even", "odd", "division", "Java", "math", "operators", "syntax", "interview"]
    },
    {
      "id": 34,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 34; int b = 3;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "1",
      "explanation": "34 divided by 3 is 11 remainder 1, so 34 % 3 = 1.\n\nExamples:\n1. `int a = 17, b = 3;` → Output: 2\n2. `int a = 30, b = 3;` → Output: 0\n3. `int a = 4, b = 3;` → Output: 1\n4. `int a = 1, b = 3;` → Output: 1\n// Used in modulo arithmetic and offset calculation.",
      "keywords": ["modulo", "math", "division", "remainder", "operators", "Java", "examples", "looping", "buffer", "interview"]
    },
    {
      "id": 35,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 35; int b = 4;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "3",
      "explanation": "`35 % 4` yields 3 because 4 * 8 = 32 and 35 - 32 = 3.\n\nExamples:\n1. `int a = 9, b = 4;` → Output: 1\n2. `int a = 8, b = 4;` → Output: 0\n3. `int a = 5, b = 4;` → Output: 1\n4. `int a = 12, b = 4;` → Output: 0\n// Often used in wrap-around operations like clocks or circular buffers.",
      "keywords": ["modulo", "wrap", "clock", "ring", "math", "Java", "remainder", "operators", "division", "examples"]
    },
    {
      "id": 36,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 36; int b = 1;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "0",
      "explanation": "Any number modulo 1 is always 0 since every integer is divisible by 1.\n\nExamples:\n1. `int x = 25, y = 1;` → Output: 0\n2. `int x = -10, y = 1;` → Output: 0\n3. `int x = 0, y = 1;` → Output: 0\n4. `int x = 999, y = 1;` → Output: 0\n// Useful in simplifying repetitive patterns.",
      "keywords": ["modulo", "division", "remainder", "Java", "math", "operator", "integer", "zero", "pattern", "interview"]
    },
    {
      "id": 37,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 37; int b = 2;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "1",
      "explanation": "37 divided by 2 leaves a remainder of 1 (since 2 * 18 = 36).\n\nExamples:\n1. `int a = 5, b = 2;` → Output: 1\n2. `int a = 6, b = 2;` → Output: 0\n3. `int a = 13, b = 2;` → Output: 1\n4. `int a = 100, b = 2;` → Output: 0\n// Commonly used to check even/odd numbers.",
      "keywords": ["modulo", "even", "odd", "math", "Java", "arithmetic", "remainder", "division", "operator", "parity"]
    },
    {
      "id": 38,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 38; int b = 3;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "2",
      "explanation": "`38 % 3` equals 2 because 3 * 12 = 36 and 38 - 36 = 2.\n\nExamples:\n1. `int a = 11, b = 3;` → Output: 2\n2. `int a = 12, b = 3;` → Output: 0\n3. `int a = 13, b = 3;` → Output: 1\n4. `int a = 14, b = 3;` → Output: 2\n// Useful in hashing and index distribution.",
      "keywords": ["modulo", "index", "hashing", "distribution", "Java", "math", "division", "examples", "remainder", "coding"]
    },
    {
      "id": 39,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 39; int b = 4;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "3",
      "explanation": "`39 % 4` yields 3 because 4 * 9 = 36, and 39 - 36 = 3.\n\nExamples:\n1. `int a = 15, b = 4;` → Output: 3\n2. `int a = 8, b = 4;` → Output: 0\n3. `int a = 9, b = 4;` → Output: 1\n4. `int a = 16, b = 4;` → Output: 0\n// Seen in scenarios where periodic overflow must be avoided.",
      "keywords": ["modulo", "periodic", "overflow", "cyclic", "Java", "arithmetic", "math", "wrap", "buffer", "examples"]
    },
    {
      "id": 40,
      "topic": "Java Interview Essentials",
      "question": "What does the following code output?\n\nint a = 40; int b = 1;\nSystem.out.println(a % b);",
      "options": ["0", "1", "2", "3", "Compilation Error"],
      "response": "0",
      "explanation": "Any integer modulo 1 always results in 0. Here, 40 % 1 = 0.\n\nExamples:\n1. `int x = 1 % 1;` → Output: 0\n2. `int x = 1000 % 1;` → Output: 0\n3. `int x = -50 % 1;` → Output: 0\n4. `int x = 99999 % 1;` → Output: 0\n// Use cases include normalizing indices and calendar rotations.",
      "keywords": ["modulo", "arithmetic", "Java", "normalize", "rotation", "division", "integer", "examples", "buffer", "zero"]
    },
    {
      "id": 41,
      "topic": "Variables, Data Types, and Operators",
      "question": "What is the output of the following code?\n\nbyte b = 127;\nb++;\nSystem.out.println(b);",
      "options": ["128", "-128", "127", "Compilation Error", "0"],
      "response": "-128",
      "explanation": "In Java, `byte` has a range from -128 to 127. When it overflows (127 + 1), it wraps around to -128 due to 2's complement representation.\n\nExamples:\n1. `byte b = 127; b++;` → Output: -128\n2. `byte b = -128; b--;` → Output: 127\n3. `byte b = 0; b--;` → Output: -1\n4. `byte b = -1; b++;` → Output: 0\n// Byte is an 8-bit signed integer. Overflow behavior is expected in bounded types.",
      "keywords": ["byte", "overflow", "data types", "operators", "Java", "increment", "range", "casting", "2's complement", "wrapping"]
    },
    {
      "id": 42,
      "topic": "Control Flow (if, switch, loops)",
      "question": "What is the output?\n\nint i = 0;\nwhile (i < 3) {\n  if (i == 1) break;\n  System.out.print(i);\n  i++;\n}",
      "options": ["0", "01", "012", "1", "None"],
      "response": "0",
      "explanation": "Loop runs while i < 3. On first iteration, i=0 is printed. On second, i=1 triggers `break` before print.\n\nExamples:\n1. `while(i < 2) i++;` → Loop runs twice\n2. `for(int i=0; i<3; i++) { if(i==2) continue; }` → skips i==2\n3. `do {} while(i<3);` → Executes once even if condition is false\n4. `if (true) return;` → Immediately exits method\n// Control statements alter execution flow.",
      "keywords": ["control flow", "while", "break", "loop", "if", "Java", "execution", "statement", "condition", "exit"]
    },
    {
      "id": 43,
      "topic": "Arrays and Strings",
      "question": "What is the output?\n\nString s = \"abc\";\ns.concat(\"def\");\nSystem.out.println(s);",
      "options": ["abcdef", "abc", "def", "Compilation Error", "null"],
      "response": "abc",
      "explanation": "String is immutable. `concat()` returns a new string, but original `s` is unchanged unless reassigned.\n\nExamples:\n1. `s = s.concat(\"xyz\")` → Output: abcxyz\n2. \"hello\".replace(\"h\", \"j\") → Output: jello\n3. `char[] arr = {'a','b'}; new String(arr)` → Output: ab\n4. `String[] sa = new String[2]; sa[0] = \"hi\";` → Indexed string = hi\n// Always reassign string if you want to capture result.",
      "keywords": ["string", "concat", "immutable", "Java", "arrays", "char", "reference", "heap", "value", "reassignment"]
    },
    {
      "id": 44,
      "topic": "Methods and Functions",
      "question": "What is the output?\n\npublic class Main {\n  static int add(int a, int b) { return a + b; }\n  public static void main(String[] args) {\n    System.out.println(add(2, 3));\n  }\n}",
      "options": ["2", "3", "5", "Compilation Error", "null"],
      "response": "5",
      "explanation": "`add` is a static method returning the sum of two integers. Examples:\n1. add(1, 1) → 2\n2. add(0, 0) → 0\n3. add(-5, 5) → 0\n4. add(10, -3) → 7\n// Methods encapsulate logic and support reusability.",
      "keywords": ["method", "function", "static", "parameters", "return", "Java", "encapsulation", "logic", "addition", "call"]
    },
    {
      "id": 45,
      "topic": "Classes, Objects, and OOP",
      "question": "What is the output?\n\nclass A { int x = 5; }\nclass Main {\n  public static void main(String[] args) {\n    A obj = new A();\n    System.out.println(obj.x);\n  }\n}",
      "options": ["0", "5", "null", "Compilation Error", "Undefined"],
      "response": "5",
      "explanation": "Object `obj` is an instance of class A. Examples:\n1. new A().x → 5\n2. A obj = null; → accessing obj.x causes NullPointerException\n3. obj.x + 1 → 6\n4. obj.x = 10 → modifies field\n// Objects encapsulate state using fields.",
      "keywords": ["class", "object", "field", "state", "OOP", "Java", "instance", "encapsulation", "value", "reference"]
    },
    {
      "id": 46,
      "topic": "Interfaces and Enums",
      "question": "What is the output?\n\ninterface I { int get(); }\nclass C implements I { public int get() { return 42; } }\nclass Main {\n  public static void main(String[] args) {\n    I i = new C();\n    System.out.println(i.get());\n  }\n}",
      "options": ["0", "42", "null", "Compilation Error", "Runtime Error"],
      "response": "42",
      "explanation": "C implements I and overrides get(). Examples:\n1. I i = new C(); i.get() → 42\n2. Anonymous: new I() { public int get() { return 1; } }\n3. Lambda: (I) () -> 99\n4. Interface enables polymorphism.\n// Interfaces define contracts.",
      "keywords": ["interface", "implement", "Java", "polymorphism", "abstraction", "override", "method", "lambda", "anonymous", "contract"]
    },
    {
      "id": 47,
      "topic": "Exception Handling",
      "question": "What is the output?\n\ntry {\n  String s = null;\n  s.length();\n} catch (NullPointerException e) {\n  System.out.println(\"Caught\");\n}",
      "options": ["Caught", "null", "Exception", "Runtime Error", "Nothing"],
      "response": "Caught",
      "explanation": "Calling method on `null` throws NPE. Examples:\n1. s = null; s.length() → throws\n2. catch (Exception e) → catches all\n3. finally → always runs\n4. throw new IOException() → manual throw\n// Try-catch prevents app crash.",
      "keywords": ["exception", "null", "catch", "try", "Java", "NPE", "runtime", "error", "handling", "graceful"]
    },
    {
      "id": 48,
      "topic": "Collections and Generics",
      "question": "What is the output?\n\nList<String> list = new ArrayList<>();\nlist.add(\"A\");\nlist.add(\"B\");\nSystem.out.println(list.size());",
      "options": ["1", "2", "0", "null", "Compilation Error"],
      "response": "2",
      "explanation": "Two elements are added. Examples:\n1. list.add(\"X\") → size grows\n2. list.clear() → becomes 0\n3. list.get(0) → 'A'\n4. list.contains(\"B\") → true\n// Generics improve type safety.",
      "keywords": ["list", "collections", "generics", "size", "add", "Java", "arraylist", "type", "elements", "structure"]
    },
    {
      "id": 49,
      "topic": "File I/O and Serialization",
      "question": "What does this code do?\n\nFiles.write(Paths.get(\"out.txt\"), \"data\".getBytes());",
      "options": ["Writes 'data' to file", "Reads file", "Deletes file", "Compiles file", "Throws error"],
      "response": "Writes 'data' to file",
      "explanation": "It writes byte data to a file. Examples:\n1. Files.readAllLines(path) → reads text\n2. Files.exists(path) → checks presence\n3. Files.delete(path) → removes file\n4. Files.createFile(path) → new file\n// Java NIO simplifies I/O ops.",
      "keywords": ["file", "io", "write", "Java", "nio", "filesystem", "serialization", "bytes", "path", "data"]
    },
    {
      "id": 50,
      "topic": "Threads and Concurrency",
      "question": "What is the output?\n\nThread t = new Thread(() -> System.out.println(\"Running\"));\nt.start();",
      "options": ["Running", "Compilation Error", "null", "Nothing", "Exception"],
      "response": "Running",
      "explanation": "Creates a thread with a lambda Runnable. Examples:\n1. new Thread(() -> {}).start() → async\n2. Thread.sleep(1000) → pause\n3. t.join() → wait\n4. ExecutorService → thread pool\n// Use for parallel tasks.",
      "keywords": ["thread", "start", "Java", "lambda", "concurrency", "runnable", "parallel", "execution", "async", "multithreading"]
    },
    {
      "id": 51,
      "topic": "Lambda Expressions and Functional Interfaces",
      "question": "What does this print?\n\nFunction<Integer, Integer> square = x -> x * x;\nSystem.out.println(square.apply(4));",
      "options": ["4", "8", "16", "2", "Compilation Error"],
      "response": "16",
      "explanation": "Lambda `x -> x * x` applied to 4 returns 16. Examples:\n1. x -> x + 1 → increment\n2. (a, b) -> a + b → sum\n3. () -> 42 → constant\n4. str -> str.length() → string length\n// Introduced in Java 8.",
      "keywords": ["lambda", "function", "Java", "functional", "interface", "apply", "expression", "arrow", "input", "output"]
    },
    {
      "id": 52,
      "topic": "Streams and Optional",
      "question": "What is the output?\n\nList<String> names = Arrays.asList(\"a\", \"b\", \"c\");\nnames.stream().filter(x -> x.equals(\"b\")).forEach(System.out::print);",
      "options": ["a", "abc", "b", "c", "Compilation Error"],
      "response": "b",
      "explanation": "Stream filters for 'b'. Examples:\n1. map(String::toUpperCase) → transforms\n2. count() → totals\n3. findFirst().orElse(\"x\") → safe retrieval\n4. sorted() → orders\n// Streams simplify data ops.",
      "keywords": ["stream", "filter", "lambda", "Java", "processing", "functional", "list", "foreach", "filtering", "print"]
    },
    {
      "id": 53,
      "topic": "Annotations and Reflection",
      "question": "What is the output?\n\n@Deprecated\nvoid oldMethod() {}\n\nboolean isDeprecated = Main.class.getDeclaredMethod(\"oldMethod\").isAnnotationPresent(Deprecated.class);\nSystem.out.println(isDeprecated);",
      "options": ["true", "false", "Compilation Error", "null", "Exception"],
      "response": "true",
      "explanation": "Checks if method has @Deprecated annotation. Examples:\n1. @Override → compiler validates\n2. @Retention(RUNTIME) → reflection visible\n3. getAnnotations() → lists\n4. isAnnotationPresent(...) → boolean\n// Annotations add metadata.",
      "keywords": ["annotation", "reflection", "Java", "metadata", "deprecated", "method", "runtime", "class", "present", "check"]
    },{
      "id": 54,
      "topic": "Access Modifiers and Static/Final",
      "question": "What is the output?\n\nfinal int x = 5;\nx = 10;\nSystem.out.println(x);",
      "options": ["10", "5", "Compilation Error", "Runtime Error", "null"],
      "response": "Compilation Error",
      "explanation": "`final` variables cannot be reassigned after initialization. Examples: final int x = 5 → OK, x = 6 → error. Useful for constants and immutability.",
      "keywords": ["final", "static", "Java", "constant", "access", "modifier", "immutability", "compile", "variable", "assignment"]
    },
    {
      "id": 55,
      "topic": "Inner Classes",
      "question": "What is the output?\n\nclass Outer {\n  class Inner { int x = 7; }\n  Inner getInner() { return new Inner(); }\n}\npublic class Main {\n  public static void main(String[] args) {\n    Outer o = new Outer();\n    System.out.println(o.getInner().x);\n  }\n}",
      "options": ["0", "7", "null", "Compilation Error", "Runtime Error"],
      "response": "7",
      "explanation": "An inner class has access to its enclosing class. Must instantiate outer before inner. Accessed via o.getInner().x.",
      "keywords": ["inner class", "outer", "Java", "encapsulation", "nested", "structure", "instance", "field", "constructor", "access"]
    },
    {
      "id": 56,
      "topic": "Packages, Imports, and Modules",
      "question": "What is the purpose of the 'package' keyword in Java?",
      "options": ["To import a library", "To declare visibility", "To define class grouping", "To run main()", "To allocate memory"],
      "response": "To define class grouping",
      "explanation": "`package` groups related classes. Helps organize large codebases logically, such as `package com.myapp.models`.",
      "keywords": ["package", "Java", "import", "module", "grouping", "structure", "organization", "namespace", "access", "class"]
    },
    {
      "id": 57,
      "topic": "JVM, Memory Model, and Garbage Collection",
      "question": "What is the role of Garbage Collector in Java?",
      "options": ["Manage threads", "Compile code", "Free unused memory", "Optimize loops", "Store constants"],
      "response": "Free unused memory",
      "explanation": "GC reclaims memory used by objects with no references. Triggered automatically or via System.gc().",
      "keywords": ["garbage collection", "memory", "JVM", "heap", "object", "GC", "finalize", "cleanup", "reference", "lifecycle"]
    },
    {
      "id": 58,
      "topic": "JDBC and Database Access",
      "question": "What does this JDBC code do?\n\nConnection con = DriverManager.getConnection(url);\nStatement stmt = con.createStatement();\nResultSet rs = stmt.executeQuery(\"SELECT 1\");",
      "options": ["Insert record", "Create table", "Execute query", "Throw error", "Close connection"],
      "response": "Execute query",
      "explanation": "`executeQuery()` runs a read-only SQL query. Results are accessed via ResultSet.",
      "keywords": ["jdbc", "query", "sql", "Java", "database", "resultset", "execute", "statement", "connection", "read"]
    },
    {
      "id": 59,
      "topic": "JUnit and Testing",
      "question": "What is the output?\n\n@Test\npublic void testAdd() {\n  assertEquals(4, 2 + 2);\n}",
      "options": ["Pass", "Fail", "Compilation Error", "Exception", "No Output"],
      "response": "Pass",
      "explanation": "assertEquals verifies that 2+2 equals expected 4. Common in unit testing to validate logic.",
      "keywords": ["junit", "test", "assert", "pass", "fail", "Java", "unit", "validation", "annotation", "framework"]
    },
    {
      "id": 60,
      "topic": "Java 8+ Features",
      "question": "What is the output?\n\nrecord Point(int x, int y) {}\n\nPoint p = new Point(1, 2);\nSystem.out.println(p.x());",
      "options": ["1", "2", "x", "Compilation Error", "null"],
      "response": "1",
      "explanation": "`record` creates immutable data classes with auto-generated methods. Here, p.x() returns 1.",
      "keywords": ["record", "Java 14", "immutable", "data class", "getter", "concise", "structure", "fields", "accessor", "boilerplate"]
    },
    {
      "id": 61,
      "topic": "Streams (Advanced)",
      "question": "What is the result?\n\nIntStream.range(1, 4).map(x -> x * x).sum();",
      "options": ["14", "13", "12", "10", "9"],
      "response": "14",
      "explanation": "range(1,4) yields 1,2,3. Squares are 1,4,9 → sum is 14. Demonstrates functional style processing.",
      "keywords": ["stream", "range", "map", "sum", "Java", "intstream", "lambda", "transform", "pipeline", "fluent"]
    },
    {
      "id": 62,
      "topic": "Optional (Advanced)",
      "question": "What is printed?\n\nOptional<String> opt = Optional.of(\"hello\");\nSystem.out.println(opt.orElse(\"none\"));",
      "options": ["hello", "none", "Optional[hello]", "null", "Exception"],
      "response": "hello",
      "explanation": "If value is present, `orElse` returns it. Otherwise, it would fallback to \"none\".",
      "keywords": ["optional", "null-safe", "Java", "value", "present", "default", "map", "get", "safe access", "nullable"]
    },
    {
      "id": 63,
      "topic": "Switch Expressions (Java 14+)",
      "question": "What is the output?\n\nint x = switch (\"B\") {\n  case \"A\" -> 1;\n  case \"B\" -> 2;\n  default -> 0;\n};\nSystem.out.println(x);",
      "options": ["1", "2", "0", "Compilation Error", "Runtime Error"],
      "response": "2",
      "explanation": "Java 14 introduced switch expressions with return values. \"B\" matches case → returns 2.",
      "keywords": ["switch", "expression", "Java 14", "case", "arrow", "return", "control flow", "concise", "pattern", "value"]
    },
    {
      "id": 64,
      "topic": "Polymorphism",
      "question": "What is the output?\n\nclass Animal { void speak() { System.out.println(\"Animal\"); } }\nclass Dog extends Animal { void speak() { System.out.println(\"Dog\"); } }\npublic class Test {\n  public static void main(String[] args) {\n    Animal a = new Dog();\n    a.speak();\n  }\n}",
      "options": ["Animal", "Dog", "Compilation Error", "Runtime Error", "null"],
      "response": "Dog",
      "explanation": "Polymorphism allows a subclass (Dog) to override methods of the superclass (Animal). The method invoked is determined at runtime. Examples: (1) Animal a = new Dog(); → Dog, (2) Animal a = new Animal(); → Animal, (3) Dog d = (Dog) a; → valid cast, (4) a instanceof Dog → true.",
      "keywords": ["polymorphism", "inheritance", "override", "method", "Java", "OOP", "runtime", "dynamic dispatch", "animal", "dog"]
    },
    {
      "id": 65,
      "topic": "Abstraction",
      "question": "Which of the following is true about abstract classes in Java?",
      "options": ["They cannot have methods", "They must have all abstract methods", "They can be instantiated", "They can have constructors", "They cannot extend other classes"],
      "response": "They can have constructors",
      "explanation": "Abstract classes cannot be instantiated but can have constructors, concrete methods, and fields. Examples: abstract class A {} → valid, A a = new A(); → error, A() {} → constructor.",
      "keywords": ["abstraction", "abstract class", "constructor", "Java", "OOP", "design", "instantiation", "method", "class", "partial implementation"]
    },
    {
      "id": 66,
      "topic": "Encapsulation",
      "question": "Which access modifier enforces encapsulation best for class fields?",
      "options": ["public", "private", "protected", "default", "static"],
      "response": "private",
      "explanation": "`private` restricts access to within the class. Encapsulation is achieved by hiding fields and providing public getters/setters. Examples: private int age; public int getAge(); public void setAge(int a);",
      "keywords": ["encapsulation", "private", "getter", "setter", "Java", "access", "modifier", "OOP", "fields", "hiding"]
    },
    {
      "id": 67,
      "topic": "Functional Interfaces",
      "question": "Which of the following is a valid functional interface in Java?",
      "options": ["Runnable", "List", "Serializable", "Comparator", "Thread"],
      "response": "Runnable",
      "explanation": "A functional interface has exactly one abstract method. Runnable has run(). Examples: Runnable r = () -> {}; @FunctionalInterface interface X { void act(); }",
      "keywords": ["functional interface", "Java", "lambda", "runnable", "abstract method", "SAM", "interface", "stream", "functional", "functional programming"]
    },
    {
      "id": 68,
      "topic": "Method Overloading",
      "question": "What is printed?\n\nvoid print(int a) { System.out.println(\"int\"); }\nvoid print(double a) { System.out.println(\"double\"); }\n\nprint(5);",
      "options": ["int", "double", "Compilation Error", "Runtime Error", "5"],
      "response": "int",
      "explanation": "Overloading chooses the most specific match. `print(5)` matches print(int). Examples: print(5.0) → double, print('c') → int, print(5L) → error unless long exists.",
      "keywords": ["overloading", "method", "Java", "compile time", "signature", "int", "double", "specific", "resolution", "argument"]
    },
    {
      "id": 69,
      "topic": "Inheritance",
      "question": "Which keyword is used to call superclass constructor?",
      "options": ["this", "super", "base", "parent", "init"],
      "response": "super",
      "explanation": "super() calls superclass constructor. Must be first in subclass constructor. Examples: super(); super(5); super.name.",
      "keywords": ["inheritance", "super", "constructor", "Java", "base", "class", "subclass", "parent", "initialization", "OOP"]
    },
    {
      "id": 70,
      "topic": "Static Keyword",
      "question": "What is the output?\n\nclass A {\n  static int x = 5;\n  static void update() { x++; }\n}\n\nA.update();\nSystem.out.println(A.x);",
      "options": ["5", "6", "0", "Compilation Error", "Runtime Error"],
      "response": "6",
      "explanation": "Static members belong to the class, not instances. `x++` increments the shared field. Examples: A.x = 10; new A().x; main is static.",
      "keywords": ["static", "field", "method", "Java", "shared", "class", "value", "increment", "instance", "global"]
    },
    {
      "id": 71,
      "topic": "Constructor Overloading",
      "question": "What is the output?\n\nclass A {\n  int x;\n  A() { this(10); }\n  A(int x) { this.x = x; }\n}\n\nSystem.out.println(new A().x);",
      "options": ["0", "10", "null", "Compilation Error", "Runtime Error"],
      "response": "10",
      "explanation": "Constructor chaining using `this()` calls another constructor in the class. A() calls A(int). Result: x = 10.",
      "keywords": ["constructor", "overloading", "this", "Java", "chaining", "class", "field", "value", "new", "initialization"]
    },
    {
      "id": 72,
      "topic": "Default Methods in Interfaces",
      "question": "What is true about default methods in interfaces?",
      "options": ["They cannot have a body", "They must be static", "They were added in Java 8", "They override abstract methods", "They are mandatory"],
      "response": "They were added in Java 8",
      "explanation": "Default methods were introduced in Java 8 to provide method bodies in interfaces. Allows backward compatibility.",
      "keywords": ["default method", "interface", "Java 8", "implementation", "compatibility", "evolution", "method", "optional", "override", "functional"]
    },
    {
      "id": 73,
      "topic": "Primitive vs Wrapper",
      "question": "What is the output?\n\nInteger a = 127;\nInteger b = 127;\nSystem.out.println(a == b);",
      "options": ["true", "false", "Compilation Error", "null", "Exception"],
      "response": "true",
      "explanation": "Integer caching for values from -128 to 127 makes `a` and `b` refer to the same object. Use `equals()` for value comparison.",
      "keywords": ["wrapper", "integer", "primitive", "==", "equals", "Java", "caching", "autoboxing", "value", "reference"]
    },
    {
      "id": 74,
      "topic": "Autoboxing and Equality",
      "question": "What is the output?\n\nInteger a = 128;\nInteger b = 128;\nSystem.out.println(a == b);",
      "options": ["true", "false", "Compilation Error", "null", "Exception"],
      "response": "false",
      "explanation": "`Integer` objects are compared by reference with `==`. Values > 127 are not cached, so different objects. Use `.equals()` for value comparison.",
      "keywords": ["autoboxing", "wrapper", "==", "equals", "integer", "reference", "value", "comparison", "caching", "Java"]
    },
    {
      "id": 75,
      "topic": "String Pool and Comparison",
      "question": "What is the output?\n\nString s1 = \"hello\";\nString s2 = new String(\"hello\");\nSystem.out.println(s1 == s2);",
      "options": ["true", "false", "Compilation Error", "null", "Exception"],
      "response": "false",
      "explanation": "`==` compares references. `new String()` creates a new object. Use `.equals()` for content comparison.",
      "keywords": ["string", "pool", "comparison", "reference", "equals", "==", "Java", "object", "memory", "intern"]
    },
    {
      "id": 76,
      "topic": "Array Initialization",
      "question": "What is the output?\n\nint[] arr = new int[3];\nSystem.out.println(arr[0]);",
      "options": ["0", "null", "undefined", "Compilation Error", "Exception"],
      "response": "0",
      "explanation": "Primitive arrays are initialized with default values. `int` defaults to 0.",
      "keywords": ["array", "initialization", "default", "Java", "int", "primitive", "memory", "values", "index", "bounds"]
    },
    {
      "id": 77,
      "topic": "Try-Catch-Finally Flow",
      "question": "What is the output?\n\ntry {\n  return 1;\n} finally {\n  return 2;\n}",
      "options": ["1", "2", "Compilation Error", "Exception", "None"],
      "response": "2",
      "explanation": "A return in `finally` overrides the `try` return. Execution always goes through finally.",
      "keywords": ["finally", "try", "return", "Java", "execution", "override", "flow", "catch", "priority", "control"]
    },
    {
      "id": 78,
      "topic": "Integer.parseInt",
      "question": "What happens with this code?\n\nInteger.parseInt(\"012\");",
      "options": ["12", "10", "Exception", "8", "Compilation Error"],
      "response": "12",
      "explanation": "Java parses the string as decimal unless a radix is specified. `012` is not octal unless explicitly told.",
      "keywords": ["parseInt", "integer", "string", "radix", "Java", "decimal", "number", "exception", "octal", "conversion"]
    },
    {
      "id": 79,
      "topic": "Null Checks",
      "question": "What is the output?\n\nString s = null;\nif (s.equals(\"test\")) {\n  System.out.println(\"yes\");\n}",
      "options": ["yes", "no output", "Compilation Error", "Exception", "null"],
      "response": "Exception",
      "explanation": "Calling `.equals` on a null object causes a `NullPointerException`. Check for null before calling methods.",
      "keywords": ["null", "exception", "npe", "equals", "Java", "check", "safe", "optional", "reference", "nullpointer"]
    },
    {
      "id": 80,
      "topic": "Switch Fallthrough",
      "question": "What is the output?\n\nint x = 1;\nswitch (x) {\n  case 1: System.out.print(\"A\");\n  case 2: System.out.print(\"B\");\n}",
      "options": ["A", "AB", "B", "Compilation Error", "None"],
      "response": "AB",
      "explanation": "Without `break`, control falls through to the next case. Always use `break` unless fallthrough is desired.",
      "keywords": ["switch", "fallthrough", "case", "break", "Java", "control flow", "branch", "match", "execution", "statement"]
    },
    {
      "id": 81,
      "topic": "Constructor Misuse",
      "question": "What is the output?\n\nclass A {\n  void A() { System.out.println(\"A\"); }\n}\nnew A();",
      "options": ["A", "Compilation Error", "Runtime Error", "No Output", "Exception"],
      "response": "No Output",
      "explanation": "`void A()` is a method, not a constructor. Java uses default constructor silently.",
      "keywords": ["constructor", "method", "Java", "default", "declaration", "syntax", "return type", "object", "new", "class"]
    },
    {
      "id": 82,
      "topic": "Boolean Logic",
      "question": "What is the output?\n\nboolean b = false;\nif (b = true) {\n  System.out.println(\"yes\");\n}",
      "options": ["yes", "no", "Compilation Error", "Exception", "null"],
      "response": "yes",
      "explanation": "`b = true` assigns true to `b`, so the condition is always true. Common bug is confusing `=` with `==`.",
      "keywords": ["boolean", "assignment", "comparison", "logic", "Java", "if", "condition", "truth", "operator", "trap"]
    },
    {
      "id": 83,
      "topic": "StringBuilder vs String",
      "question": "What is the output?\n\nString s = \"a\";\ns.concat(\"b\");\nSystem.out.println(s);",
      "options": ["a", "ab", "b", "null", "Exception"],
      "response": "a",
      "explanation": "Strings are immutable in Java. `concat()` returns a new string. `s` remains unchanged unless reassigned.",
      "keywords": ["string", "immutable", "concat", "Java", "reference", "value", "builder", "assignment", "reassign", "object"]
    },{
      "id": 84,
      "topic": "Array Indexing",
      "question": "What is the output?\n\nint[] nums = {1, 2, 3};\nSystem.out.println(nums[3]);",
      "options": ["3", "null", "0", "ArrayIndexOutOfBoundsException", "Compilation Error"],
      "response": "ArrayIndexOutOfBoundsException",
      "explanation": "Java arrays are zero-indexed. Accessing index 3 in a 3-element array causes an exception.",
      "keywords": ["array", "index", "out of bounds", "Java", "exception", "length", "error", "zero-based", "access", "validation"]
    },
    {
      "id": 85,
      "topic": "Access Modifiers",
      "question": "Which modifier makes a method accessible only within its class?",
      "options": ["public", "protected", "private", "default", "static"],
      "response": "private",
      "explanation": "`private` is the most restrictive access level, allowing visibility only within the same class.",
      "keywords": ["access", "modifier", "private", "Java", "visibility", "encapsulation", "method", "field", "restriction", "scope"]
    },
    {
      "id": 86,
      "topic": "Immutable Objects",
      "question": "Which of the following classes is immutable?",
      "options": ["StringBuilder", "String", "ArrayList", "Date", "HashMap"],
      "response": "String",
      "explanation": "Strings are immutable. Any operation returns a new String object without altering the original.",
      "keywords": ["immutable", "String", "Java", "thread safety", "modification", "final", "object", "StringBuilder", "data", "structure"]
    },
    {
      "id": 87,
      "topic": "Static vs Instance",
      "question": "What happens here?\n\nclass A {\n  static int x = 0;\n  void increment() { x++; }\n}\n\nnew A().increment();\nnew A().increment();\nSystem.out.println(A.x);",
      "options": ["0", "1", "2", "Compilation Error", "Exception"],
      "response": "2",
      "explanation": "Static variables are shared across all instances. The method `increment()` increases the same static variable.",
      "keywords": ["static", "instance", "field", "Java", "shared", "class", "method", "counter", "object", "increment"]
    },
    {
      "id": 88,
      "topic": "Instanceof Operator",
      "question": "What is the output?\n\nString s = \"abc\";\nSystem.out.println(s instanceof Object);",
      "options": ["true", "false", "Compilation Error", "Runtime Error", "null"],
      "response": "true",
      "explanation": "`instanceof` checks object type. Every object in Java extends Object, so this is true.",
      "keywords": ["instanceof", "Java", "type", "check", "class", "inheritance", "object", "cast", "runtime", "interface"]
    },
    {
      "id": 89,
      "topic": "Recursion",
      "question": "What is the output?\n\nint fact(int n) {\n  if (n == 0) return 1;\n  else return n * fact(n - 1);\n}\nSystem.out.println(fact(3));",
      "options": ["3", "6", "9", "1", "Compilation Error"],
      "response": "6",
      "explanation": "Recursive factorial function: 3 * 2 * 1 = 6.",
      "keywords": ["recursion", "factorial", "Java", "function", "stack", "base case", "call", "math", "loop", "return"]
    },
    {
      "id": 90,
      "topic": "Type Casting",
      "question": "What happens here?\n\ndouble d = 9.8;\nint x = (int) d;\nSystem.out.println(x);",
      "options": ["9", "10", "9.8", "Exception", "Compilation Error"],
      "response": "9",
      "explanation": "Casting from double to int truncates the decimal part. Value becomes 9.",
      "keywords": ["type casting", "double", "int", "truncate", "Java", "conversion", "precision", "loss", "value", "cast"]
    },
    {
      "id": 91,
      "topic": "Overriding vs Overloading",
      "question": "Which statement is true?",
      "options": ["Overloading requires same parameters", "Overriding occurs at compile time", "Overriding allows changing return type", "Overloading can have different parameter types", "Overriding can change method name"],
      "response": "Overloading can have different parameter types",
      "explanation": "Overloading means same method name but different parameter types. Overriding means same method signature in subclass.",
      "keywords": ["overloading", "overriding", "Java", "parameters", "compile", "runtime", "method", "inheritance", "signature", "subclass"]
    },
    {
      "id": 92,
      "topic": "Do-While Loop",
      "question": "What is the output?\n\nint x = 1;\ndo {\n  System.out.print(x);\n} while (x < 1);",
      "options": ["1", "0", "No output", "Infinite loop", "Compilation Error"],
      "response": "1",
      "explanation": "`do-while` executes the body once before evaluating the condition, so it prints 1.",
      "keywords": ["do-while", "loop", "Java", "execution", "condition", "minimum", "iteration", "flow", "logic", "print"]
    },
    {
      "id": 93,
      "topic": "Final Keyword on Method",
      "question": "What does `final` on a method mean?",
      "options": ["Cannot be called", "Cannot be overridden", "Cannot be assigned", "Cannot be static", "Can only be used once"],
      "response": "Cannot be overridden",
      "explanation": "A method marked `final` cannot be overridden by subclasses. This preserves the implementation.",
      "keywords": ["final", "method", "override", "Java", "inheritance", "OOP", "restriction", "design", "security", "subclass"]
    }
  ]
}
