{
  "id": 27,
  "topic": 27,
  "data": [
  {
    "id": 1,
    "topic": "Banking Account Balance Search",
    "question": "Find the account with the highest balance using binary search on a sorted array of account balances: [1000, 2500, 5000, 7500, 10000]. What's the correct approach?",
    "options": [
      "int max = 0; for(int i=0; i<balances.length; i++) if(balances[i] > max) max = balances[i];",
      "Arrays.sort(balances); return balances[balances.length-1];",
      "Since array is sorted, return balances[balances.length-1]; // O(1)",
      "Use Collections.max() on the array"
    ],
    "response": "Since array is sorted, return balances[balances.length-1]; // O(1)",
    "explanation": "For sorted arrays, the maximum element is always at the last position. No need for searching or sorting. Time complexity O(1), space O(1). Key trick: leverage sorted property.",
    "keywords": ["binary search", "sorted array", "banking", "account balance", "time complexity", "primitives"]
  },
  {
    "id": 2,
    "topic": "E-commerce Product Sorting with Lambda",
    "question": "Sort a list of Product objects by price using Java 8 streams. Which lambda expression correctly sorts products from highest to lowest price?",
    "options": [
      "products.sort((p1, p2) -> p1.price - p2.price);",
      "products.stream().sorted(Comparator.comparing(Product::getPrice).reversed());",
      "products.sort(Comparator.comparing(p -> p.price));",
      "Collections.sort(products, (p1, p2) -> p2.price.compareTo(p1.price));"
    ],
    "response": "products.stream().sorted(Comparator.comparing(Product::getPrice).reversed());",
    "explanation": "Stream API with method reference Product::getPrice and reversed() for descending order. Clean functional approach. Comparator.comparing() handles null safety and type inference.",
    "keywords": ["lambda expressions", "streams", "sorting", "e-commerce", "objects", "method references"]
  },
  {
    "id": 3,
    "topic": "Healthcare Patient Record Lookup",
    "question": "Implement fast patient lookup by ID using HashMap. What's the most efficient way to check if patient exists and get their record?",
    "options": [
      "boolean exists = patientMap.containsKey(patientId); Patient p = patientMap.get(patientId);",
      "Patient p = patientMap.get(patientId); boolean exists = (p != null);",
      "Patient p = patientMap.getOrDefault(patientId, null); boolean exists = (p != null);",
      "Optional<Patient> p = Optional.ofNullable(patientMap.get(patientId));"
    ],
    "response": "Patient p = patientMap.get(patientId); boolean exists = (p != null);",
    "explanation": "Single HashMap lookup O(1) instead of two operations. get() returns null if key doesn't exist. Efficient for both existence check and value retrieval. Avoids redundant containsKey() call.",
    "keywords": ["hash table", "lookup", "healthcare", "patient records", "time complexity", "null check"]
  },
  {
    "id": 4,
    "topic": "Logistics Delivery Route Optimization",
    "question": "Find shortest delivery path using Dijkstra's algorithm. Which data structure is essential for implementing this efficiently?",
    "options": [
      "ArrayList to store all nodes",
      "PriorityQueue<Node> for selecting minimum distance node",
      "HashSet to avoid duplicate nodes",
      "LinkedList for path reconstruction"
    ],
    "response": "PriorityQueue<Node> for selecting minimum distance node",
    "explanation": "Dijkstra requires repeatedly selecting the unvisited node with minimum distance. PriorityQueue provides O(log n) extraction of minimum element, making algorithm efficient O((V+E)log V).",
    "keywords": ["dijkstra algorithm", "priority queue", "logistics", "shortest path", "graph algorithms", "delivery optimization"]
  },
  {
    "id": 5,
    "topic": "Retail Inventory Stack Management",
    "question": "Implement LIFO inventory system for perishable goods. Last items added should be sold first. Which operation correctly removes the most recent item?",
    "options": [
      "inventory.remove(0); // Remove first",
      "inventory.remove(inventory.size()-1); // Remove last",
      "Stack<Item> inventory; inventory.pop();",
      "Queue<Item> inventory; inventory.poll();"
    ],
    "response": "Stack<Item> inventory; inventory.pop();",
    "explanation": "Stack provides LIFO (Last In, First Out) behavior with O(1) push/pop operations. Perfect for perishable inventory where newest items should be sold first to maintain freshness.",
    "keywords": ["stack", "LIFO", "retail", "inventory management", "data structures", "perishable goods"]
  },
  {
    "id": 6,
    "topic": "Financial Moving Average Calculation",
    "question": "Calculate 3-day moving average for stock prices [100, 105, 102, 108, 95]. What's the efficient sliding window approach?",
    "options": [
      "double sum = 0; for(int i=0; i<3; i++) sum += prices[i]; return sum/3;",
      "for(int i=2; i<prices.length; i++) { double avg = (prices[i-2]+prices[i-1]+prices[i])/3; }",
      "Use two nested loops to calculate each window sum",
      "Sort the array first, then calculate averages"
    ],
    "response": "for(int i=2; i<prices.length; i++) { double avg = (prices[i-2]+prices[i-1]+prices[i])/3; }",
    "explanation": "Sliding window technique calculates each 3-day average in O(1) time. Start from index 2 (third element) and include previous 2 elements. Total time complexity O(n) for all averages.",
    "keywords": ["sliding window", "moving average", "financial", "stock prices", "time series", "primitives"]
  },
  {
    "id": 7,
    "topic": "Insurance Risk Assessment Binary Classification",
    "question": "Classify customers as high/low risk based on age and claims. If age > 65 OR claims > 3, mark as high risk. What's the correct boolean logic?",
    "options": [
      "boolean highRisk = (age > 65) && (claims > 3);",
      "boolean highRisk = (age > 65) || (claims > 3);",
      "boolean highRisk = !(age <= 65) && !(claims <= 3);",
      "boolean highRisk = (age >= 65) | (claims >= 3);"
    ],
    "response": "boolean highRisk = (age > 65) || (claims > 3);",
    "explanation": "OR logic (||) means either condition makes customer high risk. AND (&&) would require both conditions. Use || for logical OR, | is bitwise OR. Parentheses ensure correct precedence.",
    "keywords": ["boolean logic", "risk assessment", "insurance", "classification", "conditional operators", "primitives"]
  },
  {
    "id": 8,
    "topic": "Real Estate Property Matching with Sets",
    "question": "Find properties that match buyer's preferences using Set intersection. Buyer wants [pool, garage, garden], property has [pool, garden, balcony]. How to find matches?",
    "options": [
      "buyerPrefs.retainAll(propertyFeatures); return buyerPrefs.size();",
      "Set<String> matches = new HashSet<>(buyerPrefs); matches.retainAll(propertyFeatures);",
      "buyerPrefs.containsAll(propertyFeatures);",
      "Collections.disjoint(buyerPrefs, propertyFeatures);"
    ],
    "response": "Set<String> matches = new HashSet<>(buyerPrefs); matches.retainAll(propertyFeatures);",
    "explanation": "Create copy of buyer preferences, then retainAll() performs set intersection. Result contains matching features [pool, garden]. Don't modify original buyer preferences set.",
    "keywords": ["set intersection", "real estate", "property matching", "collections", "set operations", "preferences"]
  },
  {
    "id": 9,
    "topic": "Gaming Leaderboard with PriorityQueue",
    "question": "Maintain top 10 players leaderboard where highest scores are priority. Which PriorityQueue comparator keeps top scores accessible?",
    "options": [
      "PriorityQueue<Player> leaderboard = new PriorityQueue<>();",
      "PriorityQueue<Player> leaderboard = new PriorityQueue<>((p1,p2) -> p2.score - p1.score);",
      "PriorityQueue<Player> leaderboard = new PriorityQueue<>(Comparator.comparing(Player::getScore));",
      "PriorityQueue<Player> leaderboard = new PriorityQueue<>(Collections.reverseOrder());"
    ],
    "response": "PriorityQueue<Player> leaderboard = new PriorityQueue<>((p1,p2) -> p2.score - p1.score);",
    "explanation": "Lambda comparator (p1,p2) -> p2.score - p1.score creates max-heap where highest scores have priority. peek() returns highest score player. Default PriorityQueue is min-heap.",
    "keywords": ["priority queue", "gaming", "leaderboard", "lambda", "comparator", "max heap"]
  },
  {
    "id": 10,
    "topic": "Social Media Friend Recommendations BFS",
    "question": "Find mutual friends (friends of friends) using BFS traversal. What's the correct approach to explore 2 levels deep?",
    "options": [
      "Use DFS recursive traversal",
      "Queue<User> queue; for each friend, add their friends to queue with level tracking",
      "Use HashMap to store all connections",
      "Sort friends list and use binary search"
    ],
    "response": "Queue<User> queue; for each friend, add their friends to queue with level tracking",
    "explanation": "BFS with Queue explores friends level by level. Track current level (1=direct friends, 2=friends of friends). Stop at level 2. Queue ensures breadth-first exploration for mutual friend discovery.",
    "keywords": ["BFS", "social media", "friend recommendations", "graph traversal", "queue", "level tracking"]
  },
  {
    "id": 11,
    "topic": "Streaming Content Recommendation Algorithm",
    "question": "Recommend content based on user viewing history using collaborative filtering. Calculate similarity between users with dot product of rating vectors [4,5,2] and [3,4,5]. What's the result?",
    "options": [
      "int similarity = 4*3 + 5*4 + 2*5; // = 42",
      "double similarity = Math.sqrt(Math.pow(4-3,2) + Math.pow(5-4,2) + Math.pow(2-5,2));",
      "int similarity = Math.abs(4-3) + Math.abs(5-4) + Math.abs(2-5);",
      "double similarity = (4+5+2) - (3+4+5);"
    ],
    "response": "int similarity = 4*3 + 5*4 + 2*5; // = 42",
    "explanation": "Dot product calculates similarity between rating vectors. Sum of element-wise multiplication: 4×3 + 5×4 + 2×5 = 12+20+10 = 42. Higher values indicate more similar preferences.",
    "keywords": ["dot product", "collaborative filtering", "streaming", "recommendation algorithm", "vector similarity", "primitives"]
  },
  {
    "id": 12,
    "topic": "Travel Flight Booking Optimization",
    "question": "Find cheapest flight combination using dynamic programming. For connecting flights, what's the optimal substructure?",
    "options": [
      "Cheapest path to destination = min(direct flight, cheapest path through each stopover)",
      "Sort all flights by price and pick cheapest",
      "Use greedy approach: always pick cheapest next flight",
      "Calculate all possible combinations and compare"
    ],
    "response": "Cheapest path to destination = min(direct flight, cheapest path through each stopover)",
    "explanation": "Dynamic programming: optimal solution contains optimal solutions to subproblems. Cheapest route to destination is minimum of direct flight cost or cost through intermediate cities plus their optimal costs.",
    "keywords": ["dynamic programming", "travel", "flight booking", "optimization", "optimal substructure", "minimum cost"]
  },
  {
    "id": 13,
    "topic": "Food Delivery Order Processing Queue",
    "question": "Process food orders FIFO with priority for VIP customers. Which data structure combination handles both requirements?",
    "options": [
      "Single PriorityQueue with VIP flag",
      "Two separate queues: VIP Queue and Regular Queue, process VIP first",
      "ArrayList with custom sorting",
      "Stack for LIFO processing"
    ],
    "response": "Two separate queues: VIP Queue and Regular Queue, process VIP first",
    "explanation": "Dual queue system: VIP orders go to high-priority queue, regular orders to normal queue. Process all VIP orders first (FIFO within VIP), then regular orders (FIFO). Maintains fairness within each tier.",
    "keywords": ["queue", "FIFO", "food delivery", "priority processing", "VIP customers", "dual queue system"]
  },
  {
    "id": 14,
    "topic": "Cryptocurrency Transaction Validation Hashing",
    "question": "Validate blockchain transaction integrity using hash comparison. Which approach correctly verifies transaction hasn't been tampered with?",
    "options": [
      "Compare transaction amounts only",
      "String originalHash = transaction.getHash(); String computedHash = SHA256(transaction.getData()); return originalHash.equals(computedHash);",
      "Check timestamp differences",
      "Verify digital signatures only"
    ],
    "response": "String originalHash = transaction.getHash(); String computedHash = SHA256(transaction.getData()); return originalHash.equals(computedHash);",
    "explanation": "Hash verification: recompute hash of transaction data and compare with stored hash. Any data modification changes hash value. SHA256 provides cryptographic security for blockchain integrity.",
    "keywords": ["hashing", "cryptocurrency", "blockchain", "transaction validation", "SHA256", "data integrity"]
  },
  {
    "id": 15,
    "topic": "Education Student Grade Sorting with Streams",
    "question": "Sort students by GPA descending, then by name ascending using Java 8 streams. What's the correct chained comparator?",
    "options": [
      "students.sort(Comparator.comparing(Student::getGpa).thenComparing(Student::getName));",
      "students.stream().sorted(Comparator.comparing(Student::getGpa).reversed().thenComparing(Student::getName));",
      "students.sort((s1,s2) -> s1.gpa > s2.gpa ? -1 : s1.name.compareTo(s2.name));",
      "Collections.sort(students, Comparator.comparing(Student::getName).thenComparing(Student::getGpa));"
    ],
    "response": "students.stream().sorted(Comparator.comparing(Student::getGpa).reversed().thenComparing(Student::getName));",
    "explanation": "Chained comparators: first sort by GPA descending (reversed()), then by name ascending (natural order). thenComparing() provides secondary sort criteria for tie-breaking.",
    "keywords": ["sorting", "education", "student grades", "streams", "chained comparators", "method references"]
  },
  {
    "id": 16,
    "topic": "Manufacturing Quality Control Statistics",
    "question": "Calculate defect rate percentage from production batch. Out of 1000 items, 25 are defective. What's the correct calculation avoiding integer division?",
    "options": [
      "int defectRate = (25 / 1000) * 100;",
      "double defectRate = (25.0 / 1000) * 100;",
      "double defectRate = (25 / 1000.0) * 100;",
      "double defectRate = (double)(25 / 1000) * 100;"
    ],
    "response": "double defectRate = (25.0 / 1000) * 100;",
    "explanation": "Use double literal (25.0) to force floating-point division. Integer division 25/1000 = 0, losing precision. Result: 2.5%. Either operand as double promotes entire expression to double.",
    "keywords": ["statistics", "manufacturing", "quality control", "floating point", "percentage calculation", "primitives"]
  },
  {
    "id": 17,
    "topic": "Telecommunications Network Tree Traversal",
    "question": "Find all network nodes within 3 hops using tree traversal. Which approach correctly limits the search depth?",
    "options": [
      "Use DFS with depth parameter: void dfs(Node node, int depth) { if(depth > 3) return; }",
      "Use BFS and stop after processing 3 levels",
      "Use iterative deepening search",
      "Both DFS with depth limit and BFS with level tracking are correct"
    ],
    "response": "Both DFS with depth limit and BFS with level tracking are correct",
    "explanation": "Both algorithms can limit search depth. DFS with depth parameter stops recursion at depth 3. BFS processes nodes level by level, stopping after level 3. Choice depends on whether you need all nodes or shortest paths.",
    "keywords": ["tree traversal", "telecommunications", "network topology", "DFS", "BFS", "depth limiting"]
  },
  {
    "id": 18,
    "topic": "Agriculture Crop Yield Array Analysis",
    "question": "Find the best 3-day consecutive period for crop yield from daily data [10, 15, 8, 20, 25, 12, 18]. What's the maximum sum of 3 consecutive days?",
    "options": [
      "int maxSum = 0; for(int i=0; i<=yield.length-3; i++) { int sum = yield[i]+yield[i+1]+yield[i+2]; maxSum = Math.max(maxSum, sum); }",
      "Arrays.sort(yield); return yield[yield.length-1] + yield[yield.length-2] + yield[yield.length-3];",
      "int sum = yield[0] + yield[1] + yield[2]; return sum;",
      "Use binary search to find maximum values"
    ],
    "response": "int maxSum = 0; for(int i=0; i<=yield.length-3; i++) { int sum = yield[i]+yield[i+1]+yield[i+2]; maxSum = Math.max(maxSum, sum); }",
    "explanation": "Sliding window approach: check each consecutive 3-day period. Calculate sum for each window and track maximum. Loop until i<=length-3 to avoid index out of bounds. Maximum sum is 65 (20+25+12).",
    "keywords": ["sliding window", "agriculture", "crop yield", "array analysis", "consecutive elements", "maximum sum"]
  },
  {
    "id": 19,
    "topic": "Energy Grid Load Balancing Dynamic Programming",
    "question": "Optimize power distribution across 4 generators with capacities [100, 200, 150, 300] to meet demand of 400 units. Which DP approach minimizes cost?",
    "options": [
      "Greedy: use cheapest generators first",
      "Use 2D DP table: dp[generator][remaining_demand] = min cost to satisfy demand",
      "Sort generators by capacity and use largest first",
      "Random allocation across generators"
    ],
    "response": "Use 2D DP table: dp[generator][remaining_demand] = min cost to satisfy demand",
    "explanation": "DP table tracks minimum cost to satisfy remaining demand using generators 0 to i. State transition: dp[i][demand] = min(don't use generator i, use generator i with various allocations). Optimal substructure property.",
    "keywords": ["dynamic programming", "energy", "load balancing", "optimization", "2D table", "minimum cost"]
  },
  {
    "id": 20,
    "topic": "Automotive Route Planning Graph Algorithms",
    "question": "Calculate fastest route considering traffic using A* algorithm. What makes A* more efficient than Dijkstra for route planning?",
    "options": [
      "A* uses heuristic function h(n) to estimate remaining distance to destination",
      "A* always finds shorter paths than Dijkstra",
      "A* uses less memory than Dijkstra",
      "A* doesn't require priority queue"
    ],
    "response": "A* uses heuristic function h(n) to estimate remaining distance to destination",
    "explanation": "A* combines Dijkstra's guaranteed shortest path with heuristic guidance. f(n) = g(n) + h(n) where g(n) is actual cost from start, h(n) estimates cost to goal. Heuristic directs search toward destination, reducing explored nodes.",
    "keywords": ["A* algorithm", "automotive", "route planning", "heuristic function", "graph algorithms", "pathfinding"]
  },
  {
    "id": 21,
    "topic": "Banking Fraud Detection Pattern Matching",
    "question": "Detect suspicious transaction patterns using Set operations. If a customer makes 3+ transactions >$5000 within 1 hour, flag as suspicious. Which approach efficiently tracks this?",
    "options": [
      "ArrayList to store all transactions and iterate through",
      "Set<Transaction> recentLarge = new HashSet<>(); // Add if amount>5000 && withinHour, flag if size>=3",
      "Sort transactions by amount, then check time windows",
      "Use single counter variable for transaction amounts"
    ],
    "response": "Set<Transaction> recentLarge = new HashSet<>(); // Add if amount>5000 && withinHour, flag if size>=3",
    "explanation": "Set provides O(1) add/contains operations for tracking qualifying transactions. Filter by amount and time window, then check set size. Remove old transactions as time window slides. Efficient for real-time fraud detection.",
    "keywords": ["fraud detection", "banking", "set operations", "pattern matching", "time window", "real-time processing"]
  },
  {
    "id": 22,
    "topic": "E-commerce Personalized Recommendations",
    "question": "Generate product recommendations using user purchase history. Filter products by category and sort by user rating using Java 8 streams. What's the optimal chain?",
    "options": [
      "products.stream().filter(p -> p.category.equals(\"Electronics\")).sorted((p1,p2) -> p2.rating - p1.rating)",
      "products.stream().filter(p -> \"Electronics\".equals(p.category)).sorted(Comparator.comparing(Product::getRating).reversed()).collect(Collectors.toList())",
      "Collections.sort(products); products.removeIf(p -> !p.category.equals(\"Electronics\"));",
      "products.parallelStream().filter(p -> p.category == \"Electronics\").sorted()"
    ],
    "response": "products.stream().filter(p -> \"Electronics\".equals(p.category)).sorted(Comparator.comparing(Product::getRating).reversed()).collect(Collectors.toList())",
    "explanation": "Stream pipeline: filter by category (null-safe with \"Electronics\".equals()), sort by rating descending using method reference and reversed(), collect to list. Functional approach with proper null handling.",
    "keywords": ["streams", "e-commerce", "recommendations", "filtering", "sorting", "method references"]
  },
  {
    "id": 23,
    "topic": "Hospital Emergency Room Triage",
    "question": "Implement patient triage system where critical patients (severity 1) are seen before urgent (severity 2) before standard (severity 3). What's the correct priority logic?",
    "options": [
      "PriorityQueue<Patient> triage = new PriorityQueue<>((p1,p2) -> p1.severity - p2.severity);",
      "PriorityQueue<Patient> triage = new PriorityQueue<>((p1,p2) -> p2.severity - p1.severity);",
      "Queue<Patient> triage = new LinkedList<>(); // FIFO order",
      "Stack<Patient> triage = new Stack<>(); // LIFO order"
    ],
    "response": "PriorityQueue<Patient> triage = new PriorityQueue<>((p1,p2) -> p1.severity - p2.severity);",
    "explanation": "Lower severity numbers = higher priority. Comparator (p1,p2) -> p1.severity - p2.severity creates min-heap where severity 1 (critical) has highest priority, then 2 (urgent), then 3 (standard).",
    "keywords": ["priority queue", "hospital", "triage", "emergency room", "patient prioritization", "min heap"]
  },
  {
    "id": 24,
    "topic": "Supply Chain Shortest Delivery Path",
    "question": "Find shortest delivery route from warehouse to customer using weighted graph. Distance matrix: warehouse->hub=5, hub->customer=3, warehouse->customer=10. What's the shortest path cost?",
    "options": [
      "int directPath = 10; // warehouse to customer direct",
      "int viHub = 5 + 3; // warehouse->hub->customer = 8",
      "int shortestPath = Math.min(10, 5+3); // = 8",
      "Use Floyd-Warshall for all-pairs shortest path"
    ],
    "response": "int shortestPath = Math.min(10, 5+3); // = 8",
    "explanation": "Compare direct path (10) vs path through hub (5+3=8). Math.min() selects optimal route. For larger graphs, use Dijkstra's algorithm. Simple case demonstrates shortest path principle with primitive operations.",
    "keywords": ["shortest path", "supply chain", "delivery route", "weighted graph", "optimization", "primitives"]
  },
  {
    "id": 25,
    "topic": "Social Media Feed Merge Algorithm",
    "question": "Merge posts from multiple friends' feeds sorted by timestamp. Each friend's feed is already sorted. Which algorithm efficiently merges k sorted feeds?",
    "options": [
      "Concatenate all feeds then sort the result",
      "Use k-way merge with PriorityQueue<Post> comparing timestamps",
      "Use binary search to insert each post",
      "Merge feeds two at a time using nested loops"
    ],
    "response": "Use k-way merge with PriorityQueue<Post> comparing timestamps",
    "explanation": "K-way merge maintains one element from each feed in priority queue ordered by timestamp. Extract minimum, add next post from same feed. Time: O(n log k) where n=total posts, k=number of feeds. Efficient for real-time feed aggregation.",
    "keywords": ["merge algorithm", "social media", "feed aggregation", "k-way merge", "priority queue", "timestamp sorting"]
  },
  {
    "id": 26,
    "topic": "Insurance Claim Binary Search Tree",
    "question": "Search for insurance claims by claim amount in BST. Tree contains claim amounts [1000, 500, 1500, 300, 750, 1200, 2000]. Find all claims between $600-$1300. What's the efficient approach?",
    "options": [
      "In-order traversal to get sorted list, then linear search",
      "Recursive BST range search: if(root.amount >= 600 && root.amount <= 1300) add to result; recurse left/right based on bounds",
      "Convert BST to array, use binary search",
      "Level-order traversal checking each node"
    ],
    "response": "Recursive BST range search: if(root.amount >= 600 && root.amount <= 1300) add to result; recurse left/right based on bounds",
    "explanation": "BST range query: if current node is in range, add to result. Recurse left if range extends below current, recurse right if range extends above. Prune branches outside range for efficiency.",
    "keywords": ["binary search tree", "insurance", "range query", "claim processing", "recursive search", "BST traversal"]
  },
  {
    "id": 27,
    "topic": "Gaming Player Matchmaking Skill Rating",
    "question": "Match players with similar skill ratings using heap data structure. For player with rating 1200, find players within ±100 rating points. How to efficiently maintain player pool?",
    "options": [
      "ArrayList and linear search through all players",
      "Two heaps: maxHeap for players below 1200, minHeap for players above 1200",
      "TreeSet<Player> sorted by rating, use subSet(1100, 1300) for range query",
      "HashMap with rating as key, List<Player> as value"
    ],
    "response": "TreeSet<Player> sorted by rating, use subSet(1100, 1300) for range query",
    "explanation": "TreeSet maintains players sorted by rating. subSet(1100, 1300) returns view of players in range with O(log n + k) complexity where k is result size. Efficient for matchmaking queries.",
    "keywords": ["matchmaking", "gaming", "skill rating", "TreeSet", "range query", "sorted collections"]
  },
  {
    "id": 28,
    "topic": "Real Estate Property Valuation Regression",
    "question": "Predict house price using linear regression: price = bedrooms×50000 + sqft×100 + 25000. For house with 3 bedrooms, 2000 sqft, calculate predicted price.",
    "options": [
      "int price = 3 * 50000 + 2000 * 100 + 25000;",
      "double price = 3.0 * 50000 + 2000.0 * 100 + 25000;",
      "int price = (3 + 2000) * (50000 + 100) + 25000;",
      "double price = Math.pow(3, 50000) + Math.pow(2000, 100) + 25000;"
    ],
    "response": "int price = 3 * 50000 + 2000 * 100 + 25000;",
    "explanation": "Linear regression formula: multiply each feature by its coefficient and sum. 3×50000 + 2000×100 + 25000 = 150000 + 200000 + 25000 = $375,000. Integer arithmetic sufficient for this calculation.",
    "keywords": ["linear regression", "real estate", "property valuation", "prediction", "mathematical formula", "primitives"]
  },
  {
    "id": 29,
    "topic": "Telecommunications Bandwidth Sliding Window",
    "question": "Monitor network bandwidth usage over 5-minute sliding windows. Given per-minute data [10, 15, 20, 25, 18, 12, 30], find maximum bandwidth in any 5-minute window.",
    "options": [
      "int maxBandwidth = Arrays.stream(data).max().orElse(0);",
      "int maxSum = 0; for(int i=0; i<=data.length-5; i++) { int sum = Arrays.stream(data, i, i+5).sum(); maxSum = Math.max(maxSum, sum); }",
      "Collections.sort(Arrays.asList(data)); return sum of top 5 values;",
      "int sum = data[0]+data[1]+data[2]+data[3]+data[4]; return sum;"
    ],
    "response": "int maxSum = 0; for(int i=0; i<=data.length-5; i++) { int sum = Arrays.stream(data, i, i+5).sum(); maxSum = Math.max(maxSum, sum); }",
    "explanation": "Sliding window technique: check each consecutive 5-minute period. Arrays.stream(data, i, i+5) creates stream from index i to i+5. Find maximum sum across all windows. Result: 88 (15+20+25+18+12).",
    "keywords": ["sliding window", "telecommunications", "bandwidth monitoring", "maximum sum", "stream API", "network analysis"]
  },
  {
    "id": 30,
    "topic": "Food Delivery Route Optimization TSP",
    "question": "Optimize delivery route visiting 4 restaurants [A,B,C,D] and returning to base. Using nearest neighbor heuristic, if distances are A->B=3, A->C=5, A->D=4, B->C=2, B->D=6, C->D=3, what's the greedy path from A?",
    "options": [
      "A->B(3)->C(2)->D(3)->A = total distance needs return cost",
      "A->D->C->B->A (choose farthest first)",
      "A->B->C->D->A (nearest neighbor: A closest to B=3, then B closest to C=2, then C closest to D=3)",
      "Sort all distances and pick shortest edges"
    ],
    "response": "A->B->C->D->A (nearest neighbor: A closest to B=3, then B closest to C=2, then C closest to D=3)",
    "explanation": "Nearest neighbor heuristic: from current location, go to nearest unvisited location. From A, nearest is B(3). From B, nearest unvisited is C(2). From C, nearest unvisited is D(3). Return to A.",
    "keywords": ["TSP", "food delivery", "route optimization", "nearest neighbor", "greedy algorithm", "heuristic"]
  },
  {
    "id": 31,
    "topic": "Cryptocurrency Mining Hash Validation",
    "question": "Validate blockchain block hash with proof-of-work. Hash must start with specific number of zeros. Which method correctly counts leading zeros in hash string?",
    "options": [
      "int zeros = 0; for(char c : hash.toCharArray()) if(c == '0') zeros++; else break;",
      "int zeros = hash.length() - hash.replaceAll(\"0\", \"\").length();",
      "boolean valid = hash.startsWith(\"0000\");",
      "int zeros = hash.indexOf('1') != -1 ? hash.indexOf('1') : hash.length();"
    ],
    "response": "int zeros = 0; for(char c : hash.toCharArray()) if(c == '0') zeros++; else break;",
    "explanation": "Count consecutive leading zeros by iterating from start until first non-zero character. Break on first non-'0' to count only leading zeros, not total zeros. Essential for proof-of-work difficulty validation.",
    "keywords": ["cryptocurrency", "mining", "hash validation", "proof of work", "leading zeros", "string processing"]
  },
  {
    "id": 32,
    "topic": "Education Course Scheduling Topological Sort",
    "question": "Schedule courses with prerequisites using topological sort. If Course A requires B, B requires C, and D requires A, what's a valid course order?",
    "options": [
      "A, B, C, D",
      "C, B, A, D",
      "D, A, B, C",
      "B, C, A, D"
    ],
    "response": "C, B, A, D",
    "explanation": "Topological sort of DAG: C has no prerequisites (start here), B requires C, A requires B, D requires A. Valid order respects all prerequisite relationships. C→B→A→D satisfies all dependencies.",
    "keywords": ["topological sort", "education", "course scheduling", "prerequisites", "DAG", "dependency resolution"]
  },
  {
    "id": 33,
    "topic": "Manufacturing Assembly Line LCS",
    "question": "Find optimal assembly sequence using Longest Common Subsequence. Two production lines have sequences [A,B,C,D,E] and [A,C,E,F,G]. What's the LCS length for shared operations?",
    "options": [
      "LCS length = 5 (all elements from first sequence)",
      "LCS length = 3 (A, C, E are common in order)",
      "LCS length = 2 (only A and E)",
      "LCS length = 1 (only one match)"
    ],
    "response": "LCS length = 3 (A, C, E are common in order)",
    "explanation": "LCS finds longest subsequence common to both sequences while preserving order. Sequence 1: [A,B,C,D,E], Sequence 2: [A,C,E,F,G]. Common ordered subsequence: [A,C,E] has length 3.",
    "keywords": ["LCS", "manufacturing", "assembly line", "sequence optimization", "dynamic programming", "common subsequence"]
  },
  {
    "id": 34,
    "topic": "Agriculture Weather Time Series Analysis",
    "question": "Analyze rainfall pattern using moving average. Daily rainfall data [5,8,3,12,6,9,4] mm. Calculate 3-day moving average for day 4 (index 3).",
    "options": [
      "double avg = (rainfall[3]) / 1; // Only current day",
      "double avg = (rainfall[1] + rainfall[2] + rainfall[3]) / 3.0; // Previous 3 days including current",
      "double avg = (rainfall[0] + rainfall[1] + rainfall[2]) / 3.0; // First 3 days",
      "double avg = (rainfall[3] + rainfall[4] + rainfall[5]) / 3.0; // Current and next 2 days"
    ],
    "response": "double avg = (rainfall[1] + rainfall[2] + rainfall[3]) / 3.0; // Previous 3 days including current",
    "explanation": "3-day moving average for day 4 (index 3) includes days 2,3,4 (indices 1,2,3). Values: 8+3+12 = 23, average = 23/3.0 = 7.67mm. Use 3.0 for floating-point division.",
    "keywords": ["time series", "agriculture", "weather analysis", "moving average", "rainfall data", "floating point"]
  },
  {
    "id": 35,
    "topic": "Energy Smart Grid Load Forecasting",
    "question": "Predict next hour energy consumption using exponential smoothing: forecast = α×current + (1-α)×previous_forecast. With α=0.3, current=100kW, previous_forecast=90kW, what's the next forecast?",
    "options": [
      "double forecast = 0.3 * 100 + 0.7 * 90;",
      "double forecast = 0.3 * 90 + 0.7 * 100;",
      "double forecast = (100 + 90) / 2;",
      "double forecast = Math.max(100, 90);"
    ],
    "response": "double forecast = 0.3 * 100 + 0.7 * 90;",
    "explanation": "Exponential smoothing formula: α×current + (1-α)×previous. With α=0.3: 0.3×100 + 0.7×90 = 30 + 63 = 93kW. Higher α gives more weight to recent observations.",
    "keywords": ["exponential smoothing", "energy", "load forecasting", "smart grid", "time series prediction", "primitives"]
  },
  {
    "id": 36,
    "topic": "Automotive Traffic Flow Floyd-Warshall",
    "question": "Find shortest travel times between all city intersections using Floyd-Warshall algorithm. For 3 intersections with direct times: 1->2=5min, 2->3=3min, 1->3=10min, what's the shortest 1->3 time?",
    "options": [
      "Direct path 1->3 = 10 minutes",
      "Via intersection 2: 1->2->3 = 5+3 = 8 minutes",
      "Math.min(10, 5+3) = 8 minutes (choose shorter path)",
      "Floyd-Warshall not needed for 3 nodes"
    ],
    "response": "Math.min(10, 5+3) = 8 minutes (choose shorter path)",
    "explanation": "Floyd-Warshall compares direct path (10) vs path through intermediate node 2 (5+3=8). Shorter path is via intersection 2. Algorithm principle: if distance[i][k] + distance[k][j] < distance[i][j], update shortest path.",
    "keywords": ["Floyd-Warshall", "automotive", "traffic flow", "all-pairs shortest path", "route optimization", "graph algorithms"]
  },
  {
    "id": 37,
    "topic": "Healthcare Diagnosis Decision Tree",
    "question": "Build medical diagnosis decision tree. Patient symptoms: fever=true, cough=true, age=65. Decision rule: if(fever && age>60) -> \"High Risk\", else if(cough) -> \"Monitor\", else -> \"Low Risk\". What's the diagnosis?",
    "options": [
      "String diagnosis = fever && age > 60 ? \"High Risk\" : cough ? \"Monitor\" : \"Low Risk\";",
      "String diagnosis = cough ? \"Monitor\" : \"Low Risk\"; // Check cough first",
      "String diagnosis = age > 60 ? \"High Risk\" : \"Low Risk\"; // Only check age",
      "String diagnosis = fever ? \"High Risk\" : \"Low Risk\"; // Only check fever"
    ],
    "response": "String diagnosis = fever && age > 60 ? \"High Risk\" : cough ? \"Monitor\" : \"Low Risk\";",
    "explanation": "Decision tree evaluation with nested ternary operator. First condition (fever && age>60) evaluates to true (fever=true, age=65>60), so diagnosis is \"High Risk\". Short-circuit evaluation prevents checking other conditions.",
    "keywords": ["decision tree", "healthcare", "medical diagnosis", "conditional logic", "ternary operator", "boolean expressions"]
  },
  {
    "id": 38,
    "topic": "Retail Inventory FIFO Queue Management",
    "question": "Implement FIFO inventory for perishable goods. First items added should be sold first. Which queue operation correctly processes a sale?",
    "options": [
      "inventory.poll(); // Remove and return head element",
      "inventory.peek(); // Look at head without removing",
      "inventory.offer(item); // Add item to tail",
      "inventory.remove(item); // Remove specific item"
    ],
    "response": "inventory.poll(); // Remove and return head element",
    "explanation": "Queue.poll() removes and returns the head element (first item added). Perfect for FIFO inventory where oldest items are sold first. Returns null if queue is empty. poll() is safe alternative to remove().",
    "keywords": ["FIFO", "retail", "inventory management", "queue operations", "perishable goods", "first in first out"]
  },
  {
    "id": 39,
    "topic": "Financial Monte Carlo Risk Simulation",
    "question": "Simulate portfolio risk using Monte Carlo method. Generate 1000 random portfolio returns with mean=8%, std=15%. Which approach correctly generates normal distribution?",
    "options": [
      "Random rand = new Random(); double return = rand.nextGaussian() * 0.15 + 0.08;",
      "Random rand = new Random(); double return = rand.nextDouble() * 0.15 + 0.08;",
      "Random rand = new Random(); double return = rand.nextGaussian() + 0.08;",
      "Math.random() * 0.15 + 0.08;"
    ],
    "response": "Random rand = new Random(); double return = rand.nextGaussian() * 0.15 + 0.08;",
    "explanation": "nextGaussian() generates standard normal distribution (mean=0, std=1). Transform to desired distribution: multiply by target std (0.15), add target mean (0.08). Formula: value = std×Z + mean.",
    "keywords": ["Monte Carlo", "financial", "risk simulation", "normal distribution", "random generation", "portfolio analysis"]
  },
  {
    "id": 40,
    "topic": "Logistics Warehouse Union-Find Operations",
    "question": "Track connected warehouse zones using Union-Find. Zones A,B,C are initially separate. After union(A,B) and union(B,C), how many connected components remain?",
    "options": [
      "3 components (A, B, C still separate)",
      "2 components (AB connected, C separate)",
      "1 component (A, B, C all connected through B)",
      "0 components (all nodes removed)"
    ],
    "response": "1 component (A, B, C all connected through B)",
    "explanation": "Union-Find tracks connected components. union(A,B) connects A and B. union(B,C) connects B and C, which transitively connects A to C through B. All three zones are now in one connected component.",
    "keywords": ["union-find", "logistics", "warehouse management", "connected components", "disjoint set", "graph connectivity"]
  },
  {
    "id": 41,
    "topic": "Banking Interest Calculation Primitives",
    "question": "Calculate compound interest for savings account. Principal=$1000, rate=5% annually, time=3 years. Use formula: amount = principal * (1 + rate)^time. What's the correct primitive calculation?",
    "options": [
      "double amount = 1000 * Math.pow(1.05, 3);",
      "int amount = 1000 * (1 + 5) * 3;",
      "double amount = 1000 + (1000 * 0.05 * 3);",
      "float amount = 1000f * 1.05f * 3f;"
    ],
    "response": "double amount = 1000 * Math.pow(1.05, 3);",
    "explanation": "Compound interest uses exponential growth: principal × (1 + rate)^time. Math.pow(1.05, 3) = 1.157625, so amount = 1000 × 1.157625 = $1157.63. Use double for precision in financial calculations.",
    "keywords": ["compound interest", "banking", "primitive calculation", "Math.pow", "double precision", "financial math"]
  },
  {
    "id": 42,
    "topic": "Retail Sales Tax Array Processing",
    "question": "Calculate total sales tax from item prices array. prices[] = {10, 25, 15, 30}, tax rate = 8.5%. Which loop correctly sums the tax?",
    "options": [
      "double totalTax = 0; for(int i = 0; i < prices.length; i++) totalTax += prices[i] * 0.085;",
      "int totalTax = 0; for(int price : prices) totalTax += price * 8.5;",
      "double totalTax = 0; for(int price : prices) totalTax += price + 0.085;",
      "float totalTax = 0f; for(int i = 0; i <= prices.length; i++) totalTax += prices[i] * 0.085f;"
    ],
    "response": "double totalTax = 0; for(int i = 0; i < prices.length; i++) totalTax += prices[i] * 0.085;",
    "explanation": "Enhanced for loop or traditional for loop both work. Key: use double for tax calculations, multiply by 0.085 (8.5%), use < (not <=) to avoid array bounds exception. Total tax = (10+25+15+30) × 0.085 = $6.80.",
    "keywords": ["array processing", "retail", "sales tax", "for loop", "primitive arrays", "double precision"]
  },
  {
    "id": 43,
    "topic": "Insurance Risk Score Boolean Logic",
    "question": "Calculate insurance risk score using boolean conditions. Age=45, hasAccidents=true, creditScore=750. Risk = high if (age>50 OR hasAccidents) AND creditScore<700. What's the result?",
    "options": [
      "boolean highRisk = (45 > 50 || true) && 750 < 700;",
      "boolean highRisk = (45 > 50 || hasAccidents) && creditScore < 700;",
      "boolean highRisk = (age > 50 || hasAccidents) && creditScore < 700;",
      "boolean highRisk = age > 50 && hasAccidents && creditScore < 700;"
    ],
    "response": "boolean highRisk = (age > 50 || hasAccidents) && creditScore < 700;",
    "explanation": "Boolean logic: (45>50 OR true) AND 750<700 = (false OR true) AND false = true AND false = false. Not high risk because creditScore≥700. Use primitive variables for clean logic evaluation.",
    "keywords": ["boolean logic", "insurance", "risk assessment", "conditional operators", "primitive variables", "logical AND OR"]
  },
  {
    "id": 44,
    "topic": "Healthcare Temperature Monitoring Array",
    "question": "Find fever episodes in patient temperature readings. temps[] = {98.6, 101.2, 99.8, 102.1, 98.9}. Count readings ≥100.4°F (fever threshold). What's the count?",
    "options": [
      "int feverCount = 0; for(double temp : temps) if(temp >= 100.4) feverCount++;",
      "int feverCount = 0; for(int i = 0; i < temps.length; i++) if(temps[i] > 100.4) feverCount++;",
      "int feverCount = 0; for(double temp : temps) if(temp == 100.4) feverCount++;",
      "double feverCount = 0.0; for(double temp : temps) if(temp >= 100.4) feverCount++;"
    ],
    "response": "int feverCount = 0; for(double temp : temps) if(temp >= 100.4) feverCount++;",
    "explanation": "Enhanced for loop iterates through double array. Count temperatures ≥100.4 (inclusive). Readings 101.2 and 102.1 qualify, so feverCount = 2. Use int counter for discrete counting.",
    "keywords": ["array iteration", "healthcare", "temperature monitoring", "enhanced for loop", "counting", "double array"]
  },
  {
    "id": 45,
    "topic": "Manufacturing Quality Control Statistical Analysis",
    "question": "Calculate defect rate percentage from production data. defects=15, totalProduced=500. Express as percentage with 2 decimal places. What's the correct calculation?",
    "options": [
      "double defectRate = (15 / 500) * 100;",
      "double defectRate = (15.0 / 500.0) * 100.0;",
      "int defectRate = (15 * 100) / 500;",
      "float defectRate = 15f / 500f * 100f;"
    ],
    "response": "double defectRate = (15.0 / 500.0) * 100.0;",
    "explanation": "Use double literals (15.0, 500.0) to force floating-point division. Integer division 15/500=0, losing precision. Result: 15.0/500.0 × 100.0 = 3.0%. Double provides sufficient precision for percentage calculations.",
    "keywords": ["percentage calculation", "manufacturing", "quality control", "floating point division", "double precision", "statistical analysis"]
  },
  {
    "id": 46,
    "topic": "Automotive Fuel Efficiency Primitive Calculation",
    "question": "Calculate miles per gallon for delivery truck. Distance=240 miles, fuel used=12 gallons. Round result to 1 decimal place using primitive operations.",
    "options": [
      "double mpg = 240 / 12;",
      "double mpg = 240.0 / 12.0;",
      "double mpg = Math.round((240.0 / 12.0) * 10.0) / 10.0;",
      "int mpg = 240 / 12;"
    ],
    "response": "double mpg = Math.round((240.0 / 12.0) * 10.0) / 10.0;",
    "explanation": "MPG calculation: 240.0/12.0 = 20.0. For 1 decimal rounding: multiply by 10, round to nearest integer, divide by 10. Math.round(20.0×10)/10.0 = 200/10.0 = 20.0 mpg.",
    "keywords": ["fuel efficiency", "automotive", "rounding", "Math.round", "primitive division", "decimal precision"]
  },
  {
    "id": 47,
    "topic": "E-commerce Price Comparison Primitive Array",
    "question": "Find cheapest product from price array using linear search. prices[] = {29, 15, 42, 8, 33}. Track both minimum price and its index position.",
    "options": [
      "int minPrice = prices[0]; int minIndex = 0; for(int i = 1; i < prices.length; i++) if(prices[i] < minPrice) { minPrice = prices[i]; minIndex = i; }",
      "int minPrice = Integer.MAX_VALUE; for(int i = 0; i < prices.length; i++) if(prices[i] < minPrice) minPrice = prices[i];",
      "int minPrice = 0; for(int price : prices) if(price < minPrice) minPrice = price;",
      "int minPrice = prices[0]; for(int price : prices) minPrice = Math.min(minPrice, price);"
    ],
    "response": "int minPrice = prices[0]; int minIndex = 0; for(int i = 1; i < prices.length; i++) if(prices[i] < minPrice) { minPrice = prices[i]; minIndex = i; }",
    "explanation": "Initialize with first element, track both value and index. Loop from index 1, update both minPrice and minIndex when smaller value found. Result: minPrice=8, minIndex=3. Need index for product identification.",
    "keywords": ["linear search", "e-commerce", "price comparison", "minimum finding", "array traversal", "index tracking"]
  },
  {
    "id": 48,
    "topic": "Telecommunications Signal Strength Bitwise Operations",
    "question": "Check signal quality flags using bitwise operations. signalFlags=0b1101 (binary). Bit 0=connected, bit 1=encrypted, bit 2=high speed, bit 3=roaming. Check if encrypted (bit 1) is set.",
    "options": [
      "boolean encrypted = (signalFlags & 0b0010) != 0;",
      "boolean encrypted = (signalFlags | 0b0010) == 1;",
      "boolean encrypted = (signalFlags ^ 0b0010) == 0;",
      "boolean encrypted = signalFlags % 2 == 1;"
    ],
    "response": "boolean encrypted = (signalFlags & 0b0010) != 0;",
    "explanation": "Bitwise AND with mask 0b0010 isolates bit 1. signalFlags=0b1101 & 0b0010 = 0b0000 = 0, so encrypted=false. If bit 1 were set, result would be non-zero. AND operation checks specific bit positions.",
    "keywords": ["bitwise operations", "telecommunications", "signal flags", "bit manipulation", "AND operation", "flag checking"]
  },
  {
    "id": 49,
    "topic": "Agriculture Crop Yield Averaging Primitive Math",
    "question": "Calculate average crop yield per acre from field data. yields[] = {120, 135, 108, 142, 156} bushels. Use integer division and handle remainder properly.",
    "options": [
      "int total = 0; for(int yield : yields) total += yield; int average = total / yields.length;",
      "double total = 0; for(int yield : yields) total += yield; double average = total / yields.length;",
      "int total = 0; for(int yield : yields) total += yield; double average = (double)total / yields.length;",
      "int average = (120 + 135 + 108 + 142 + 156) / 5;"
    ],
    "response": "int total = 0; for(int yield : yields) total += yield; double average = (double)total / yields.length;",
    "explanation": "Sum using int accumulator: 120+135+108+142+156=661. Cast to double before division to preserve decimal precision: 661.0/5 = 132.2 bushels per acre. Avoids integer division truncation.",
    "keywords": ["averaging", "agriculture", "crop yield", "type casting", "integer division", "primitive accumulation"]
  },
  {
    "id": 50,
    "topic": "Energy Consumption Peak Detection",
    "question": "Find peak energy usage hour from hourly consumption data. usage[] = {45, 52, 48, 67, 43, 39, 56}. Identify hour with maximum consumption and its value.",
    "options": [
      "int maxUsage = usage[0]; int peakHour = 0; for(int i = 1; i < usage.length; i++) if(usage[i] > maxUsage) { maxUsage = usage[i]; peakHour = i; }",
      "int maxUsage = 0; for(int i = 0; i < usage.length; i++) if(usage[i] > maxUsage) maxUsage = usage[i];",
      "int maxUsage = Integer.MIN_VALUE; for(int value : usage) maxUsage = Math.max(maxUsage, value);",
      "int maxUsage = usage[usage.length - 1]; int peakHour = usage.length - 1;"
    ],
    "response": "int maxUsage = usage[0]; int peakHour = 0; for(int i = 1; i < usage.length; i++) if(usage[i] > maxUsage) { maxUsage = usage[i]; peakHour = i; }",
    "explanation": "Track both maximum value and its position. Initialize with first element, compare remaining elements. Result: maxUsage=67, peakHour=3 (4th hour). Need both value and time for energy management decisions.",
    "keywords": ["peak detection", "energy", "consumption monitoring", "maximum finding", "array search", "position tracking"]
  },
  {
    "id": 51,
    "topic": "Banking Account Number Validation Checksum",
    "question": "Validate 4-digit account PIN using checksum algorithm. PIN=1234, checksum = (sum of digits) mod 10. If checksum equals last digit, PIN is valid. Is PIN 1234 valid?",
    "options": [
      "int sum = 1 + 2 + 3 + 4; boolean valid = (sum % 10) == 4;",
      "int sum = 1234; boolean valid = (sum % 10) == 4;",
      "char[] digits = \"1234\".toCharArray(); int sum = 0; for(char c : digits) sum += Character.getNumericValue(c); boolean valid = (sum % 10) == 4;",
      "boolean valid = 1234 % 10 == 4;"
    ],
    "response": "int sum = 1 + 2 + 3 + 4; boolean valid = (sum % 10) == 4;",
    "explanation": "Sum of digits: 1+2+3+4=10. Checksum: 10 mod 10 = 0. Last digit is 4. Since 0 ≠ 4, PIN is invalid. Simple arithmetic validation using modulo operation for checksum verification.",
    "keywords": ["checksum validation", "banking", "PIN verification", "modulo operation", "digit sum", "primitive arithmetic"]
  },
  {
    "id": 52,
    "topic": "Retail Discount Calculation Conditional Logic",
    "question": "Apply tiered discount based on purchase amount. amount=$150. Discount: 0% if <$100, 10% if $100-$199, 20% if ≥$200. Calculate final price using conditional logic.",
    "options": [
      "double discount = amount < 100 ? 0.0 : amount < 200 ? 0.10 : 0.20; double finalPrice = amount - (amount * discount);",
      "double finalPrice = amount >= 200 ? amount * 0.8 : amount >= 100 ? amount * 0.9 : amount;",
      "double discount = 0.10; double finalPrice = amount * (1.0 - discount);",
      "double finalPrice = amount - (amount > 100 ? 10 : 0);"
    ],
    "response": "double finalPrice = amount >= 200 ? amount * 0.8 : amount >= 100 ? amount * 0.9 : amount;",
    "explanation": "Nested ternary operator for tiered pricing. $150 falls in $100-$199 range, so 10% discount applies. Final price = $150 × 0.9 = $135. Direct calculation of final price avoiding intermediate variables.",
    "keywords": ["tiered discount", "retail", "conditional logic", "ternary operator", "percentage calculation", "pricing logic"]
  },
  {
    "id": 53,
    "topic": "Healthcare Medication Dosage Time Calculation",
    "question": "Calculate medication intervals. Take 500mg every 8 hours for 5 days. Total doses needed and total medication amount. Use primitive arithmetic.",
    "options": [
      "int hoursPerDay = 24; int dosesPerDay = hoursPerDay / 8; int totalDoses = dosesPerDay * 5; int totalMg = totalDoses * 500;",
      "int totalDoses = 5 * 3; int totalMg = totalDoses * 500;",
      "int totalMg = 500 * 8 * 5;",
      "double dosesPerDay = 24.0 / 8.0; int totalDoses = (int)(dosesPerDay * 5); int totalMg = totalDoses * 500;"
    ],
    "response": "int hoursPerDay = 24; int dosesPerDay = hoursPerDay / 8; int totalDoses = dosesPerDay * 5; int totalMg = totalDoses * 500;",
    "explanation": "Step-by-step calculation: 24 hours ÷ 8 hour intervals = 3 doses/day. 3 doses/day × 5 days = 15 total doses. 15 doses × 500mg = 7500mg total. Clear variable naming for medical calculations.",
    "keywords": ["medication dosage", "healthcare", "time intervals", "arithmetic progression", "step calculation", "primitive math"]
  },
  {
    "id": 54,
    "topic": "Social Media Post Engagement Rate Calculation",
    "question": "Calculate engagement rate from post metrics. likes=250, comments=45, shares=30, followers=5000. Engagement rate = (total interactions / followers) × 100. What's the rate?",
    "options": [
      "double engagementRate = ((250 + 45 + 30) / 5000) * 100;",
      "double engagementRate = ((250.0 + 45.0 + 30.0) / 5000.0) * 100.0;",
      "int totalInteractions = 250 + 45 + 30; double engagementRate = (totalInteractions / 5000.0) * 100;",
      "float engagementRate = (250f + 45f + 30f) / 5000f * 100f;"
    ],
    "response": "double engagementRate = ((250.0 + 45.0 + 30.0) / 5000.0) * 100.0;",
    "explanation": "Total interactions: 250+45+30=325. Engagement rate: (325.0/5000.0)×100.0 = 6.5%. Use double literals to ensure floating-point division for accurate percentage calculation.",
    "keywords": ["engagement rate", "social media", "percentage calculation", "metrics analysis", "floating point arithmetic", "rate calculation"]
  },
  {
    "id": 55,
    "topic": "Manufacturing Production Rate Efficiency",
    "question": "Calculate production efficiency. Target=100 units/hour, actual production=[95, 105, 98, 102, 96] units in 5 hours. Find efficiency percentage for each hour.",
    "options": [
      "for(int i = 0; i < production.length; i++) { double efficiency = (production[i] / 100.0) * 100; }",
      "for(int actual : production) { double efficiency = (actual / 100.0) * 100.0; }",
      "for(int i = 0; i < production.length; i++) { int efficiency = production[i] * 100 / 100; }",
      "for(int actual : production) { float efficiency = actual / 100f * 100f; }"
    ],
    "response": "for(int actual : production) { double efficiency = (actual / 100.0) * 100.0; }",
    "explanation": "Efficiency = (actual/target) × 100. For each hour: 95/100×100=95%, 105/100×100=105%, etc. Enhanced for loop with double precision for accurate percentage calculations.",
    "keywords": ["production efficiency", "manufacturing", "percentage calculation", "enhanced for loop", "performance metrics", "efficiency analysis"]
  },
  {
    "id": 56,
    "topic": "Financial Loan Payment Primitive Recursion",
    "question": "Calculate factorial for financial combinatorics (loan approval scenarios). Calculate 5! using primitive recursion. What's the base case and recursive call?",
    "options": [
      "int factorial(int n) { return n == 0 ? 1 : n * factorial(n - 1); }",
      "int factorial(int n) { return n == 1 ? 1 : n * factorial(n - 1); }",
      "int factorial(int n) { return n <= 1 ? 1 : n * factorial(n - 1); }",
      "int factorial(int n) { return n == 0 ? 0 : n * factorial(n - 1); }"
    ],
    "response": "int factorial(int n) { return n <= 1 ? 1 : n * factorial(n - 1); }",
    "explanation": "Base case: n≤1 returns 1 (handles both 0! and 1!). Recursive case: n × factorial(n-1). For 5!: 5×4×3×2×1=120. Covers edge cases 0!=1 and 1!=1 correctly.",
    "keywords": ["factorial", "financial", "recursion", "base case", "primitive recursion", "combinatorics"]
  },
  {
    "id": 57,
    "topic": "Logistics Distance Matrix Primitive Comparison",
    "question": "Compare delivery routes using 2D distance matrix. distances[3][3] = {{0,5,10},{5,0,3},{10,3,0}}. Find shortest route from city 0 to city 2 (direct vs via city 1).",
    "options": [
      "int direct = distances[0][2]; int viaCity1 = distances[0][1] + distances[1][2]; int shortest = Math.min(direct, viaCity1);",
      "int shortest = distances[0][2];",
      "int shortest = distances[0][1] + distances[1][2];",
      "int shortest = Math.max(distances[0][2], distances[0][1] + distances[1][2]);"
    ],
    "response": "int direct = distances[0][2]; int viaCity1 = distances[0][1] + distances[1][2]; int shortest = Math.min(direct, viaCity1);",
    "explanation": "Compare direct route (distances[0][2] = 10) vs route via city 1 (distances[0][1] + distances[1][2] = 5+3 = 8). Math.min(10, 8) = 8. Route via city 1 is shorter.",
    "keywords": ["distance matrix", "logistics", "route comparison", "2D array", "shortest path", "Math.min"]
  },
  {
    "id": 58,
    "topic": "Gaming Score Leaderboard Array Sorting",
    "question": "Sort player scores in descending order using bubble sort with primitive array. scores[] = {85, 92, 78, 96, 81}. Show one pass of bubble sort.",
    "options": [
      "for(int i = 0; i < scores.length - 1; i++) { if(scores[i] < scores[i + 1]) { int temp = scores[i]; scores[i] = scores[i + 1]; scores[i + 1] = temp; } }",
      "for(int i = 0; i < scores.length - 1; i++) { if(scores[i] > scores[i + 1]) { int temp = scores[i]; scores[i] = scores[i + 1]; scores[i + 1] = temp; } }",
      "for(int i = 0; i < scores.length; i++) { if(scores[i] < scores[i + 1]) { scores[i] = scores[i + 1]; } }",
      "Arrays.sort(scores); Collections.reverse(Arrays.asList(scores));"
    ],
    "response": "for(int i = 0; i < scores.length - 1; i++) { if(scores[i] < scores[i + 1]) { int temp = scores[i]; scores[i] = scores[i + 1]; scores[i + 1] = temp; } }",
    "explanation": "Bubble sort for descending order: swap if current element is smaller than next (scores[i] < scores[i+1]). One pass bubbles largest element to front. Use temp variable for swapping primitive values.",
    "keywords": ["bubble sort", "gaming", "leaderboard", "descending order", "primitive swapping", "array sorting"]
  },
  {
    "id": 59,
    "topic": "Real Estate Property Tax Assessment",
    "question": "Calculate property tax using primitive operations. Property value=$200,000, tax rate=1.25% annually. Express rate as decimal and calculate tax amount.",
    "options": [
      "double taxRate = 1.25 / 100.0; double tax = 200000 * taxRate;",
      "double tax = 200000 * 1.25 / 100;",
      "int tax = 200000 * 125 / 10000;",
      "double tax = 200000 * 0.0125;"
    ],
    "response": "double taxRate = 1.25 / 100.0; double tax = 200000 * taxRate;",
    "explanation": "Convert percentage to decimal: 1.25% = 1.25/100.0 = 0.0125. Tax = $200,000 × 0.0125 = $2,500. Clear variable naming and step-by-step calculation for financial transparency.",
    "keywords": ["property tax", "real estate", "percentage conversion", "tax calculation", "decimal conversion", "financial calculation"]
  },
  {
    "id": 60,
    "topic": "Agriculture Irrigation Schedule Modulo Operations",
    "question": "Schedule irrigation every 3 days starting day 1. For day 14, determine if irrigation is needed using modulo operation. Day 1,4,7,10,13... need irrigation.",
    "options": [
      "boolean needsIrrigation = (14 % 3) == 1;",
      "boolean needsIrrigation = (14 % 3) == 0;",
      "boolean needsIrrigation = ((14 - 1) % 3) == 0;",
      "boolean needsIrrigation = (14 / 3) == 0;"
    ],
    "response": "boolean needsIrrigation = ((14 - 1) % 3) == 0;",
    "explanation": "Pattern: days 1,4,7,10,13... = 1+3n. Transform to 0-based: (day-1) mod 3. For day 14: (14-1) mod 3 = 13 mod 3 = 1 ≠ 0, so no irrigation needed. Day 13 would need irrigation.",
    "keywords": ["irrigation schedule", "agriculture", "modulo operation", "periodic scheduling", "pattern recognition", "remainder calculation"]
  },
  {
    "id": 61,
    "topic": "Retail Profit Margin Calculation Primitives",
    "question": "Calculate profit margin for retail product. baseCost=$20, sellingPrice=$35. Profit margin = ((sellingPrice - baseCost) / sellingPrice) × 100. What's the correct primitive calculation?",
    "options": [
      "double profitMargin = ((35 - 20) / 35) * 100;",
      "double profitMargin = ((35.0 - 20.0) / 35.0) * 100.0;",
      "int profitMargin = (35 - 20) * 100 / 35;",
      "float profit = 35f - 20f; float margin = profit / 35f * 100f;"
    ],
    "response": "double profitMargin = ((35.0 - 20.0) / 35.0) * 100.0;",
    "explanation": "Profit margin formula: (sellingPrice - baseCost) / sellingPrice × 100. Use double literals to ensure floating-point division. Result: (15.0/35.0) × 100.0 = 42.86% profit margin.",
    "keywords": ["profit margin", "retail", "primitive calculation", "base cost", "selling price", "percentage"]
  },
  {
    "id": 62,
    "topic": "Retail Most Sold Product Array Analysis",
    "question": "Find bestselling product from sales array. productSales[] = {150, 89, 203, 67, 145}. Track both maximum sales count and product index using primitives.",
    "options": [
      "int maxSales = productSales[0]; int bestProductIndex = 0; for(int i = 1; i < productSales.length; i++) if(productSales[i] > maxSales) { maxSales = productSales[i]; bestProductIndex = i; }",
      "int maxSales = 0; for(int sales : productSales) if(sales > maxSales) maxSales = sales;",
      "int bestProductIndex = 0; for(int i = 0; i < productSales.length; i++) if(productSales[i] > productSales[bestProductIndex]) bestProductIndex = i;",
      "int maxSales = Integer.MIN_VALUE; for(int i = 0; i < productSales.length; i++) maxSales = Math.max(maxSales, productSales[i]);"
    ],
    "response": "int maxSales = productSales[0]; int bestProductIndex = 0; for(int i = 1; i < productSales.length; i++) if(productSales[i] > maxSales) { maxSales = productSales[i]; bestProductIndex = i; }",
    "explanation": "Track both maximum sales value and its index position. Initialize with first element, compare remaining elements. Result: maxSales=203, bestProductIndex=2 (third product). Need index to identify specific product.",
    "keywords": ["bestselling product", "retail", "maximum finding", "array analysis", "product sales", "index tracking"]
  },
  {
    "id": 63,
    "topic": "Retail Refund Processing Boolean Logic",
    "question": "Process customer refund request. daysSincePurchase=25, hasReceipt=true, itemCondition='N' (New). Refund policy: ≤30 days AND has receipt AND condition is 'N' or 'G'. Is refund approved?",
    "options": [
      "boolean refundApproved = daysSincePurchase <= 30 && hasReceipt && (itemCondition == 'N' || itemCondition == 'G');",
      "boolean refundApproved = daysSincePurchase < 30 && hasReceipt && itemCondition == 'N';",
      "boolean refundApproved = daysSincePurchase <= 30 || hasReceipt || itemCondition == 'N';",
      "boolean refundApproved = (daysSincePurchase <= 30) && (hasReceipt) && (itemCondition != 'U');"
    ],
    "response": "boolean refundApproved = daysSincePurchase <= 30 && hasReceipt && (itemCondition == 'N' || itemCondition == 'G');",
    "explanation": "All conditions must be met (AND logic): 25≤30 ✓, hasReceipt=true ✓, condition='N' ✓. Result: true && true && true = true. Refund approved. Character comparison uses == operator.",
    "keywords": ["refund processing", "retail", "boolean logic", "char comparison", "policy validation", "conditional logic"]
  },
  {
    "id": 64,
    "topic": "Retail Inventory Cost Calculation Primitive Arrays",
    "question": "Calculate total inventory value from base costs and quantities. baseCosts[] = {15, 25, 40}, quantities[] = {100, 50, 30}. Sum all (baseCost × quantity) products.",
    "options": [
      "int totalValue = 0; for(int i = 0; i < baseCosts.length; i++) totalValue += baseCosts[i] * quantities[i];",
      "int totalValue = 0; for(int cost : baseCosts) for(int qty : quantities) totalValue += cost * qty;",
      "int totalValue = (baseCosts[0] + baseCosts[1] + baseCosts[2]) * (quantities[0] + quantities[1] + quantities[2]);",
      "double totalValue = 0.0; for(int i = 0; i < baseCosts.length; i++) totalValue += baseCosts[i] + quantities[i];"
    ],
    "response": "int totalValue = 0; for(int i = 0; i < baseCosts.length; i++) totalValue += baseCosts[i] * quantities[i];",
    "explanation": "Parallel array processing: multiply corresponding elements and sum. totalValue = (15×100) + (25×50) + (40×30) = 1500 + 1250 + 1200 = $3950. Use index-based loop for parallel arrays.",
    "keywords": ["inventory value", "retail", "parallel arrays", "base cost", "quantity calculation", "primitive multiplication"]
  },
  {
    "id": 65,
    "topic": "Retail Discount Tier System Conditional Logic",
    "question": "Apply customer loyalty discount tiers. loyaltyYears=3, totalPurchase=$250. Discount: 0-1yr=5%, 2-3yr=10%, 4+yr=15%. Calculate final price after discount.",
    "options": [
      "double discount = loyaltyYears <= 1 ? 0.05 : loyaltyYears <= 3 ? 0.10 : 0.15; double finalPrice = totalPurchase * (1.0 - discount);",
      "double discount = loyaltyYears >= 4 ? 0.15 : loyaltyYears >= 2 ? 0.10 : 0.05; double finalPrice = totalPurchase - (totalPurchase * discount);",
      "int discountPercent = loyaltyYears <= 1 ? 5 : loyaltyYears <= 3 ? 10 : 15; double finalPrice = totalPurchase * (100 - discountPercent) / 100;",
      "double finalPrice = totalPurchase * (loyaltyYears <= 1 ? 0.95 : loyaltyYears <= 3 ? 0.90 : 0.85);"
    ],
    "response": "double finalPrice = totalPurchase * (loyaltyYears <= 1 ? 0.95 : loyaltyYears <= 3 ? 0.90 : 0.85);",
    "explanation": "3 years = 10% discount tier. Multiply by (1 - discount rate): $250 × 0.90 = $225. Direct calculation using nested ternary operator for clean tier-based pricing logic.",
    "keywords": ["loyalty discount", "retail", "tier system", "ternary operator", "discount calculation", "customer loyalty"]
  },
  {
    "id": 66,
    "topic": "Retail Sales Commission Primitive Calculation",
    "question": "Calculate sales representative commission. baseSalary=2000, totalSales=15000, commissionRate=3.5%. Commission = baseSalary + (totalSales × commissionRate). What's the total pay?",
    "options": [
      "double totalPay = 2000 + (15000 * 3.5 / 100);",
      "double totalPay = 2000.0 + (15000.0 * 0.035);",
      "int totalPay = 2000 + 15000 * 35 / 1000;",
      "float totalPay = 2000f + 15000f * 3.5f / 100f;"
    ],
    "response": "double totalPay = 2000.0 + (15000.0 * 0.035);",
    "explanation": "Commission calculation: $2000 + ($15000 × 0.035) = $2000 + $525 = $2525. Use decimal rate (0.035) for cleaner calculation. Double precision ensures accurate financial calculations.",
    "keywords": ["sales commission", "retail", "commission rate", "base salary", "percentage calculation", "compensation"]
  },
  {
    "id": 67,
    "topic": "Retail Product Cost Analysis Profit Calculation",
    "question": "Determine minimum selling price for 25% profit margin. baseCost=$80. Formula: sellingPrice = baseCost / (1 - profitMargin). Calculate required selling price.",
    "options": [
      "double sellingPrice = 80 / (1 - 0.25);",
      "double sellingPrice = 80.0 / (1.0 - 0.25);",
      "double sellingPrice = 80 * 1.25;",
      "int sellingPrice = 80 + (80 * 25 / 100);"
    ],
    "response": "double sellingPrice = 80.0 / (1.0 - 0.25);",
    "explanation": "Profit margin formula rearranged: sellingPrice = baseCost / (1 - margin). $80 / (1.0 - 0.25) = $80 / 0.75 = $106.67. This ensures 25% profit margin on selling price.",
    "keywords": ["profit margin", "retail", "selling price", "base cost", "margin calculation", "pricing strategy"]
  },
  {
    "id": 68,
    "topic": "Retail Return Processing Day Calculation",
    "question": "Check return eligibility based on purchase date. purchaseDay=15, currentDay=38, returnPolicy=30 days. Calculate days elapsed and determine eligibility using primitive comparison.",
    "options": [
      "int daysElapsed = currentDay - purchaseDay; boolean eligible = daysElapsed <= 30;",
      "int daysElapsed = Math.abs(currentDay - purchaseDay); boolean eligible = daysElapsed <= 30;",
      "boolean eligible = (currentDay - purchaseDay) <= 30;",
      "int daysElapsed = currentDay - purchaseDay; boolean eligible = daysElapsed < 30;"
    ],
    "response": "int daysElapsed = currentDay - purchaseDay; boolean eligible = daysElapsed <= 30;",
    "explanation": "Days elapsed: 38 - 15 = 23 days. Since 23 ≤ 30, return is eligible. Simple arithmetic with boolean comparison for policy enforcement. Use <= for inclusive 30-day policy.",
    "keywords": ["return policy", "retail", "date calculation", "eligibility check", "primitive comparison", "time difference"]
  },
  {
    "id": 69,
    "topic": "Retail Bulk Purchase Discount Primitive Logic",
    "question": "Apply bulk discount based on quantity. quantity=75, unitPrice=12, baseCost=8. Discount: 50-99 units=5% off baseCost. Calculate total cost with discount.",
    "options": [
      "double discountedCost = quantity >= 50 && quantity < 100 ? baseCost * 0.95 : baseCost; double totalCost = quantity * discountedCost;",
      "double totalCost = quantity * baseCost * (quantity >= 50 ? 0.95 : 1.0);",
      "int discount = quantity >= 50 && quantity < 100 ? 5 : 0; double totalCost = quantity * baseCost * (100 - discount) / 100;",
      "double totalCost = quantity * (baseCost - (quantity >= 50 ? baseCost * 0.05 : 0));"
    ],
    "response": "double discountedCost = quantity >= 50 && quantity < 100 ? baseCost * 0.95 : baseCost; double totalCost = quantity * discountedCost;",
    "explanation": "75 units qualifies for 5% bulk discount. Discounted cost: $8 × 0.95 = $7.60. Total cost: 75 × $7.60 = $570. Clear separation of discount logic and total calculation.",
    "keywords": ["bulk discount", "retail", "quantity discount", "base cost", "conditional pricing", "volume pricing"]
  },
  {
    "id": 70,
    "topic": "Retail Most Profitable Product Analysis",
    "question": "Find most profitable product from profit per unit array. profitsPerUnit[] = {5.50, 8.25, 3.75, 12.00, 6.80}. Find maximum profit and product index using primitives.",
    "options": [
      "double maxProfit = profitsPerUnit[0]; int mostProfitableIndex = 0; for(int i = 1; i < profitsPerUnit.length; i++) if(profitsPerUnit[i] > maxProfit) { maxProfit = profitsPerUnit[i]; mostProfitableIndex = i; }",
      "double maxProfit = 0.0; for(double profit : profitsPerUnit) if(profit > maxProfit) maxProfit = profit;",
      "int mostProfitableIndex = 0; for(int i = 0; i < profitsPerUnit.length; i++) if(profitsPerUnit[i] > profitsPerUnit[mostProfitableIndex]) mostProfitableIndex = i;",
      "double maxProfit = Double.MIN_VALUE; for(int i = 0; i < profitsPerUnit.length; i++) maxProfit = Math.max(maxProfit, profitsPerUnit[i]);"
    ],
    "response": "double maxProfit = profitsPerUnit[0]; int mostProfitableIndex = 0; for(int i = 1; i < profitsPerUnit.length; i++) if(profitsPerUnit[i] > maxProfit) { maxProfit = profitsPerUnit[i]; mostProfitableIndex = i; }",
    "explanation": "Track both maximum profit value and product index. Initialize with first element, compare remaining. Result: maxProfit=$12.00, mostProfitableIndex=3 (fourth product). Essential for profit optimization decisions.",
    "keywords": ["most profitable", "retail", "profit analysis", "double array", "maximum finding", "product optimization"]
  },
  {
    "id": 71,
    "topic": "Retail Refund Amount Calculation Primitives",
    "question": "Calculate partial refund amount. originalPrice=$45, daysUsed=8, totalReturnDays=30. Refund = originalPrice × (remainingDays / totalReturnDays). Calculate refund amount.",
    "options": [
      "double refundAmount = originalPrice * ((totalReturnDays - daysUsed) / totalReturnDays);",
      "double refundAmount = originalPrice * ((30.0 - 8.0) / 30.0);",
      "int remainingDays = totalReturnDays - daysUsed; double refundAmount = originalPrice * remainingDays / 30.0;",
      "double refundAmount = 45.0 * (22.0 / 30.0);"
    ],
    "response": "double refundAmount = originalPrice * ((30.0 - 8.0) / 30.0);",
    "explanation": "Remaining days: 30 - 8 = 22 days. Refund: $45 × (22.0/30.0) = $45 × 0.733 = $33.00. Use floating-point literals for accurate percentage calculation of partial refund.",
    "keywords": ["partial refund", "retail", "refund calculation", "time-based refund", "percentage refund", "floating point division"]
  },
  {
    "id": 72,
    "topic": "Retail Break-Even Point Calculation",
    "question": "Calculate break-even quantity. fixedCosts=5000, baseCostPerUnit=15, sellingPrice=25. Break-even = fixedCosts / (sellingPrice - baseCostPerUnit). How many units needed?",
    "options": [
      "int breakEvenUnits = 5000 / (25 - 15);",
      "double breakEvenUnits = 5000.0 / (25.0 - 15.0);",
      "int profitPerUnit = 25 - 15; int breakEvenUnits = 5000 / profitPerUnit;",
      "double breakEvenUnits = 5000 / 10.0;"
    ],
    "response": "int profitPerUnit = 25 - 15; int breakEvenUnits = 5000 / profitPerUnit;",
    "explanation": "Profit per unit: $25 - $15 = $10. Break-even: $5000 ÷ $10 = 500 units. Clear variable naming shows profit margin concept. Integer division works perfectly since result is whole number.",
    "keywords": ["break-even", "retail", "fixed costs", "profit per unit", "break-even analysis", "business calculation"]
  },
  {
    "id": 73,
    "topic": "Retail Sales Tax on Base Cost Calculation",
    "question": "Calculate total customer price including sales tax on base cost markup. baseCost=$30, markup=60%, salesTax=8.25%. Price = (baseCost × (1 + markup)) × (1 + salesTax).",
    "options": [
      "double price = (30 * 1.60) * 1.0825;",
      "double price = (30.0 * (1.0 + 0.60)) * (1.0 + 0.0825);",
      "double markedUpPrice = 30 * 1.60; double finalPrice = markedUpPrice * 1.0825;",
      "double finalPrice = 30.0 * 1.60 * 1.0825;"
    ],
    "response": "double markedUpPrice = 30 * 1.60; double finalPrice = markedUpPrice * 1.0825;",
    "explanation": "Step-by-step: Marked up price = $30 × 1.60 = $48. Final price with tax = $48 × 1.0825 = $51.96. Clear intermediate variables show markup and tax application sequence.",
    "keywords": ["markup calculation", "retail", "sales tax", "base cost", "price calculation", "compound percentage"]
  },
  {
    "id": 74,
    "topic": "Retail Seasonal Discount Array Processing",
    "question": "Apply seasonal discount to product base costs. baseCosts[] = {20, 35, 50, 25}, seasonalDiscount=15%. Create new array with discounted costs using primitive operations.",
    "options": [
      "double[] discountedCosts = new double[baseCosts.length]; for(int i = 0; i < baseCosts.length; i++) discountedCosts[i] = baseCosts[i] * 0.85;",
      "for(int i = 0; i < baseCosts.length; i++) baseCosts[i] = baseCosts[i] * 85 / 100;",
      "double[] discountedCosts = new double[baseCosts.length]; for(int i = 0; i < baseCosts.length; i++) discountedCosts[i] = baseCosts[i] - (baseCosts[i] * 0.15);",
      "int[] discountedCosts = new int[baseCosts.length]; for(int i = 0; i < baseCosts.length; i++) discountedCosts[i] = (int)(baseCosts[i] * 0.85);"
    ],
    "response": "double[] discountedCosts = new double[baseCosts.length]; for(int i = 0; i < baseCosts.length; i++) discountedCosts[i] = baseCosts[i] * 0.85;",
    "explanation": "Create new array preserving original data. Apply 15% discount by multiplying by 0.85 (1.0 - 0.15). Results: [17.00, 29.75, 42.50, 21.25]. Use double for precise decimal pricing.",
    "keywords": ["seasonal discount", "retail", "array processing", "discount application", "base cost", "array transformation"]
  },
  {
    "id": 75,
    "topic": "Retail Customer Loyalty Points Accumulation",
    "question": "Calculate loyalty points earned. purchaseAmount=$125, baseCostTotal=$75, pointsRate=2 points per dollar profit. Points = (purchaseAmount - baseCostTotal) × pointsRate.",
    "options": [
      "int points = (purchaseAmount - baseCostTotal) * pointsRate;",
      "int profit = 125 - 75; int points = profit * 2;",
      "double points = (125.0 - 75.0) * 2.0;",
      "int points = (int)((purchaseAmount - baseCostTotal) * pointsRate);"
    ],
    "response": "int profit = 125 - 75; int points = profit * 2;",
    "explanation": "Profit calculation: $125 - $75 = $50. Points earned: $50 × 2 = 100 points. Clear variable naming shows profit-based loyalty system. Integer arithmetic appropriate for point counting.",
    "keywords": ["loyalty points", "retail", "profit calculation", "points accumulation", "customer rewards", "base cost"]
  },
  {
    "id": 76,
    "topic": "Retail Product Mix Profitability Analysis",
    "question": "Calculate weighted average profit margin from product mix. products sold: [100, 150, 75], profit margins: [20%, 35%, 45%]. Find overall profit margin percentage.",
    "options": [
      "double totalSales = 100 + 150 + 75; double weightedMargin = (100*0.20 + 150*0.35 + 75*0.45) / totalSales * 100;",
      "double avgMargin = (0.20 + 0.35 + 0.45) / 3 * 100;",
      "int totalUnits = 100 + 150 + 75; double weightedMargin = (100*20 + 150*35 + 75*45) / totalUnits;",
      "double weightedMargin = ((100*0.20) + (150*0.35) + (75*0.45)) / (100+150+75);"
    ],
    "response": "double weightedMargin = ((100*0.20) + (150*0.35) + (75*0.45)) / (100+150+75);",
    "explanation": "Weighted average: (100×0.20 + 150×0.35 + 75×0.45) / 325 = (20 + 52.5 + 33.75) / 325 = 106.25/325 = 0.327 = 32.7% overall margin. Weight by sales volume.",
    "keywords": ["weighted average", "retail", "product mix", "profit margin", "profitability analysis", "sales volume"]
  },
  {
    "id": 77,
    "topic": "Retail Inventory Turnover Rate Primitive Calculation",
    "question": "Calculate inventory turnover rate. costOfGoodsSold=$240000, averageInventoryValue=$60000. Turnover = costOfGoodsSold / averageInventoryValue. Express as decimal.",
    "options": [
      "double turnoverRate = 240000 / 60000;",
      "double turnoverRate = 240000.0 / 60000.0;",
      "int turnoverRate = 240000 / 60000;",
      "float turnoverRate = 240000f / 60000f;"
    ],
    "response": "double turnoverRate = 240000.0 / 60000.0;",
    "explanation": "Inventory turnover: $240,000 ÷ $60,000 = 4.0 times per year. Use double for financial precision. Higher turnover indicates efficient inventory management and faster sales cycle.",
    "keywords": ["inventory turnover", "retail", "cost of goods sold", "inventory management", "turnover rate", "financial ratio"]
  },
  {
    "id": 78,
    "topic": "Retail Multi-Product Refund Processing",
    "question": "Process refund for multiple products with different base costs and conditions. baseCosts[] = {25, 40, 15}, refundable[] = {true, false, true}. Calculate total refund amount.",
    "options": [
      "double totalRefund = 0; for(int i = 0; i < baseCosts.length; i++) if(refundable[i]) totalRefund += baseCosts[i];",
      "double totalRefund = 0; for(int i = 0; i < baseCosts.length; i++) totalRefund += refundable[i] ? baseCosts[i] : 0;",
      "int totalRefund = 0; for(boolean canRefund : refundable) for(int cost : baseCosts) if(canRefund) totalRefund += cost;",
      "double totalRefund = baseCosts[0] + baseCosts[2]; // Only refundable items"
    ],
    "response": "double totalRefund = 0; for(int i = 0; i < baseCosts.length; i++) if(refundable[i]) totalRefund += baseCosts[i];",
    "explanation": "Process parallel arrays: add baseCost only if refundable[i] is true. Items 0 and 2 are refundable: $25 + $15 = $40 total refund. Item 1 ($40) is not refundable.",
    "keywords": ["multi-product refund", "retail", "parallel arrays", "conditional processing", "refund calculation", "boolean array"]
  },
  {
    "id": 79,
    "topic": "Retail Price Elasticity Primitive Analysis",
    "question": "Calculate price elasticity of demand. oldPrice=$50, newPrice=$55, oldQuantity=200, newQuantity=180. Elasticity = (quantityChange/oldQuantity) / (priceChange/oldPrice).",
    "options": [
      "double elasticity = ((180 - 200) / 200.0) / ((55 - 50) / 50.0);",
      "double elasticity = ((newQuantity - oldQuantity) / oldQuantity) / ((newPrice - oldPrice) / oldPrice);",
      "double quantityChange = (180.0 - 200.0) / 200.0; double priceChange = (55.0 - 50.0) / 50.0; double elasticity = quantityChange / priceChange;",
      "double elasticity = (-20.0 / 200.0) / (5.0 / 50.0);"
    ],
    "response": "double quantityChange = (180.0 - 200.0) / 200.0; double priceChange = (55.0 - 50.0) / 50.0; double elasticity = quantityChange / priceChange;",
    "explanation": "Quantity change: -20/200 = -0.10 (-10%). Price change: 5/50 = 0.10 (10%). Elasticity: -0.10/0.10 = -1.0. Clear variable separation shows economic concept breakdown.",
    "keywords": ["price elasticity", "retail", "demand analysis", "percentage change", "economic calculation", "elasticity coefficient"]
  },
  {
    "id": 80,
    "topic": "Retail Cost Plus Pricing Strategy",
    "question": "Implement cost-plus pricing strategy. baseCost=$40, desiredProfitMargin=25%, overhead=$8. Selling price = (baseCost + overhead) / (1 - profitMargin). Calculate final price.",
    "options": [
      "double sellingPrice = (40 + 8) / (1 - 0.25);",
      "double totalCost = 40.0 + 8.0; double sellingPrice = totalCost / (1.0 - 0.25);",
      "double sellingPrice = (40.0 + 8.0) / 0.75;",
      "double sellingPrice = 48.0 / (1.0 - 0.25);"
    ],
    "response": "double totalCost = 40.0 + 8.0; double sellingPrice = totalCost / (1.0 - 0.25);",
    "explanation": "Total cost: $40 + $8 = $48. Selling price: $48 ÷ (1 - 0.25) = $48 ÷ 0.75 = $64. Clear cost breakdown shows pricing methodology. Ensures 25% margin on selling price.",
    "keywords": ["cost-plus pricing", "retail", "profit margin", "overhead costs", "pricing strategy", "base cost"]
  },
  {
    "id": 81,
    "topic": "Financial Portfolio Risk Assessment Primitive Arrays",
    "question": "Calculate portfolio standard deviation for risk assessment. returns[] = {8, 12, -3, 15, 6}%. Step 1: Find mean. Step 2: Calculate variance. Step 3: Take square root. What's the pedagogical approach?",
    "options": [
      "double mean = Arrays.stream(returns).average().orElse(0); // Skip manual calculation",
      "double sum = 0; for(int r : returns) sum += r; double mean = sum / returns.length; double variance = 0; for(int r : returns) variance += Math.pow(r - mean, 2); variance /= returns.length; double stdDev = Math.sqrt(variance);",
      "double stdDev = Math.sqrt(Arrays.stream(returns).mapToDouble(x -> x).summaryStatistics().getVariance());",
      "Use library functions for all statistical calculations"
    ],
    "response": "double sum = 0; for(int r : returns) sum += r; double mean = sum / returns.length; double variance = 0; for(int r : returns) variance += Math.pow(r - mean, 2); variance /= returns.length; double stdDev = Math.sqrt(variance);",
    "explanation": "Pedagogical step-by-step approach: 1) Manual sum and mean calculation builds understanding. 2) Variance calculation shows deviation concept. 3) Square root demonstrates standard deviation derivation. Teaching strategy: break complex formulas into digestible steps.",
    "keywords": ["portfolio risk", "standard deviation", "step-by-step learning", "financial statistics", "pedagogical approach", "variance calculation"]
  },
  {
    "id": 82,
    "topic": "Investment Compound Interest Problem-Solving Strategy",
    "question": "Teach compound interest using problem decomposition. principal=$1000, rate=6% annually, time=5 years. Break down A=P(1+r)^t into learning steps. What's the educational approach?",
    "options": [
      "double amount = 1000 * Math.pow(1.06, 5); // Direct calculation",
      "System.out.println(\"Step 1: Convert rate to decimal\"); double rate = 6.0 / 100.0; System.out.println(\"Step 2: Add 1 to rate\"); double factor = 1.0 + rate; System.out.println(\"Step 3: Calculate power\"); double power = Math.pow(factor, 5); System.out.println(\"Step 4: Multiply by principal\"); double amount = 1000 * power;",
      "double amount = 1000 * 1.06 * 1.06 * 1.06 * 1.06 * 1.06; // Show repeated multiplication",
      "Use financial calculator without explanation"
    ],
    "response": "System.out.println(\"Step 1: Convert rate to decimal\"); double rate = 6.0 / 100.0; System.out.println(\"Step 2: Add 1 to rate\"); double factor = 1.0 + rate; System.out.println(\"Step 3: Calculate power\"); double power = Math.pow(factor, 5); System.out.println(\"Step 4: Multiply by principal\"); double amount = 1000 * power;",
    "explanation": "Problem-solving pedagogy: decompose complex formula into logical steps with explanatory output. Students understand why each step exists. Builds algorithmic thinking by showing formula construction, not just application.",
    "keywords": ["compound interest", "problem decomposition", "step-by-step learning", "algorithmic thinking", "financial education", "pedagogical strategy"]
  },
  {
    "id": 83,
    "topic": "Financial Trading Algorithm Pattern Recognition",
    "question": "Detect bull market pattern (3 consecutive price increases) using pattern recognition strategy. prices[] = {100, 105, 110, 108, 112, 118, 125}. How to teach pattern detection algorithms?",
    "options": [
      "boolean bullMarket = prices[6] > prices[0]; // Compare endpoints only",
      "int consecutiveIncreases = 0; boolean bullPattern = false; for(int i = 1; i < prices.length; i++) { if(prices[i] > prices[i-1]) { consecutiveIncreases++; if(consecutiveIncreases >= 3) { bullPattern = true; System.out.println(\"Bull pattern detected at index \" + i); } } else { consecutiveIncreases = 0; } }",
      "Use technical analysis library",
      "Sort prices and check if ascending"
    ],
    "response": "int consecutiveIncreases = 0; boolean bullPattern = false; for(int i = 1; i < prices.length; i++) { if(prices[i] > prices[i-1]) { consecutiveIncreases++; if(consecutiveIncreases >= 3) { bullPattern = true; System.out.println(\"Bull pattern detected at index \" + i); } } else { consecutiveIncreases = 0; } }",
    "explanation": "Pattern recognition pedagogy: teach counter-based state tracking. Shows how algorithms detect sequences, reset on pattern breaks, and report findings. Builds understanding of stateful pattern matching in trading systems.",
    "keywords": ["pattern recognition", "trading algorithm", "state tracking", "financial patterns", "sequential analysis", "bull market detection"]
  },
  {
    "id": 84,
    "topic": "Banking Loan Amortization Mathematical Reasoning",
    "question": "Calculate monthly payment using mathematical reasoning approach. loan=$50000, rate=4.5% annually, term=60 months. Formula: M = P * [r(1+r)^n] / [(1+r)^n - 1]. How to teach this systematically?",
    "options": [
      "double payment = 50000 * (0.045/12) * Math.pow(1+(0.045/12), 60) / (Math.pow(1+(0.045/12), 60) - 1);",
      "System.out.println(\"Convert annual rate to monthly\"); double monthlyRate = 0.045 / 12; System.out.println(\"Calculate (1+r)^n\"); double factor = Math.pow(1 + monthlyRate, 60); System.out.println(\"Apply amortization formula\"); double payment = 50000 * (monthlyRate * factor) / (factor - 1);",
      "Use loan calculator without showing formula",
      "Approximate using simple interest calculation"
    ],
    "response": "System.out.println(\"Convert annual rate to monthly\"); double monthlyRate = 0.045 / 12; System.out.println(\"Calculate (1+r)^n\"); double factor = Math.pow(1 + monthlyRate, 60); System.out.println(\"Apply amortization formula\"); double payment = 50000 * (monthlyRate * factor) / (factor - 1);",
    "explanation": "Mathematical reasoning strategy: break complex formula into conceptual chunks. Students learn rate conversion, exponential calculation, and formula application separately. Builds confidence in financial mathematics through structured approach.",
    "keywords": ["loan amortization", "mathematical reasoning", "formula decomposition", "financial mathematics", "step-by-step calculation", "banking"]
  },
  {
    "id": 85,
    "topic": "Financial Risk Management Monte Carlo Simulation",
    "question": "Teach Monte Carlo simulation for portfolio risk using pedagogical progression. How to build understanding from simple to complex?",
    "options": [
      "Random random = new Random(); double portfolioValue = 0; for(int i = 0; i < 1000; i++) portfolioValue += random.nextGaussian() * 0.15 + 0.08;",
      "System.out.println(\"Step 1: Single random scenario\"); Random random = new Random(42); double return1 = random.nextGaussian() * 0.15 + 0.08; System.out.println(\"Step 2: Multiple scenarios\"); for(int i = 0; i < 10; i++) { double scenario = random.nextGaussian() * 0.15 + 0.08; System.out.println(\"Scenario \" + i + \": \" + scenario + \"%\"); } System.out.println(\"Step 3: Statistical analysis\"); // Continue with full simulation",
      "Run 10000 simulations immediately",
      "Use financial modeling software"
    ],
    "response": "System.out.println(\"Step 1: Single random scenario\"); Random random = new Random(42); double return1 = random.nextGaussian() * 0.15 + 0.08; System.out.println(\"Step 2: Multiple scenarios\"); for(int i = 0; i < 10; i++) { double scenario = random.nextGaussian() * 0.15 + 0.08; System.out.println(\"Scenario \" + i + \": \" + scenario + \"%\"); } System.out.println(\"Step 3: Statistical analysis\"); // Continue with full simulation",
    "explanation": "Progressive complexity pedagogy: start with single random number, then few scenarios, finally full simulation. Students understand randomness, normal distribution, and statistical aggregation before tackling complete Monte Carlo method.",
    "keywords": ["Monte Carlo simulation", "progressive learning", "financial risk", "random simulation", "pedagogical progression", "complexity building"]
  },
  {
    "id": 86,
    "topic": "Financial Market Volatility Calculation Logic Building",
    "question": "Build logical understanding of volatility calculation. dailyReturns[] = {0.02, -0.015, 0.008, -0.01, 0.025}. Teach why we square deviations in volatility formula.",
    "options": [
      "double volatility = Arrays.stream(dailyReturns).map(Math::abs).average().orElse(0);",
      "System.out.println(\"Why square deviations?\"); System.out.println(\"Positive and negative deviations cancel out\"); double sum = 0; for(double r : dailyReturns) sum += r; double mean = sum / dailyReturns.length; System.out.println(\"Mean return: \" + mean); double sumDeviations = 0; for(double r : dailyReturns) sumDeviations += (r - mean); System.out.println(\"Sum of deviations: \" + sumDeviations + \" (near zero!)\"); double sumSquaredDeviations = 0; for(double r : dailyReturns) sumSquaredDeviations += Math.pow(r - mean, 2); System.out.println(\"Sum of squared deviations: \" + sumSquaredDeviations + \" (meaningful!)\");",
      "double volatility = Math.sqrt(Arrays.stream(dailyReturns).mapToDouble(x -> x * x).average().orElse(0));",
      "Use standard library volatility function"
    ],
    "response": "System.out.println(\"Why square deviations?\"); System.out.println(\"Positive and negative deviations cancel out\"); double sum = 0; for(double r : dailyReturns) sum += r; double mean = sum / dailyReturns.length; System.out.println(\"Mean return: \" + mean); double sumDeviations = 0; for(double r : dailyReturns) sumDeviations += (r - mean); System.out.println(\"Sum of deviations: \" + sumDeviations + \" (near zero!)\"); double sumSquaredDeviations = 0; for(double r : dailyReturns) sumSquaredDeviations += Math.pow(r - mean, 2); System.out.println(\"Sum of squared deviations: \" + sumSquaredDeviations + \" (meaningful!)\");",
    "explanation": "Logic building pedagogy: demonstrate WHY mathematical operations exist. Show that unsquared deviations cancel out, making variance meaningless. Squaring preserves magnitude while eliminating cancellation. Builds mathematical intuition.",
    "keywords": ["volatility calculation", "logic building", "mathematical intuition", "variance explanation", "deviation analysis", "financial mathematics"]
  },
  {
    "id": 87,
    "topic": "Financial Credit Score Algorithm Decision Trees",
    "question": "Implement credit scoring using decision tree logic teaching. age=35, income=75000, debtRatio=0.3, paymentHistory=0.95. Build decision tree understanding step by step.",
    "options": [
      "int creditScore = age > 25 && income > 50000 && debtRatio < 0.4 && paymentHistory > 0.9 ? 750 : 600;",
      "System.out.println(\"Decision Tree Credit Scoring\"); int score = 300; System.out.println(\"Base score: \" + score); if(age >= 25) { score += 50; System.out.println(\"Age bonus (+50): \" + score); } if(income >= 50000) { score += 100; System.out.println(\"Income bonus (+100): \" + score); } if(debtRatio <= 0.35) { score += 75; System.out.println(\"Low debt bonus (+75): \" + score); } if(paymentHistory >= 0.95) { score += 125; System.out.println(\"Excellent payment bonus (+125): \" + score); }",
      "Use machine learning credit model",
      "Apply complex weighted formula without explanation"
    ],
    "response": "System.out.println(\"Decision Tree Credit Scoring\"); int score = 300; System.out.println(\"Base score: \" + score); if(age >= 25) { score += 50; System.out.println(\"Age bonus (+50): \" + score); } if(income >= 50000) { score += 100; System.out.println(\"Income bonus (+100): \" + score); } if(debtRatio <= 0.35) { score += 75; System.out.println(\"Low debt bonus (+75): \" + score); } if(paymentHistory >= 0.95) { score += 125; System.out.println(\"Excellent payment bonus (+125): \" + score); }",
    "explanation": "Decision tree pedagogy: show additive scoring process with transparent criteria. Students understand how each factor contributes to final score. Builds algorithmic thinking about rule-based systems and financial decision making.",
    "keywords": ["credit scoring", "decision trees", "algorithmic thinking", "financial algorithms", "rule-based systems", "transparent scoring"]
  },
  {
    "id": 88,
    "topic": "Financial Time Value of Money Conceptual Learning",
    "question": "Teach present value concept using intuitive progression. futureValue=$1000, rate=5%, years=3. How to build understanding before applying formula?",
    "options": [
      "double presentValue = 1000 / Math.pow(1.05, 3);",
      "System.out.println(\"Conceptual Understanding:\"); System.out.println(\"$1000 in 3 years = ? today\"); System.out.println(\"If you invest $X today at 5%, you'll have $1000 in 3 years\"); System.out.println(\"Year 1: $X * 1.05\"); System.out.println(\"Year 2: $X * 1.05 * 1.05\"); System.out.println(\"Year 3: $X * 1.05^3 = $1000\"); System.out.println(\"Therefore: $X = $1000 / 1.05^3\"); double pv = 1000.0 / Math.pow(1.05, 3); System.out.println(\"Present Value: $\" + pv);",
      "Use present value table lookup",
      "Apply discount rate formula directly"
    ],
    "response": "System.out.println(\"Conceptual Understanding:\"); System.out.println(\"$1000 in 3 years = ? today\"); System.out.println(\"If you invest $X today at 5%, you'll have $1000 in 3 years\"); System.out.println(\"Year 1: $X * 1.05\"); System.out.println(\"Year 2: $X * 1.05 * 1.05\"); System.out.println(\"Year 3: $X * 1.05^3 = $1000\"); System.out.println(\"Therefore: $X = $1000 / 1.05^3\"); double pv = 1000.0 / Math.pow(1.05, 3); System.out.println(\"Present Value: $\" + pv);",
    "explanation": "Conceptual learning strategy: build intuition before formula application. Students understand WHY present value works through forward projection, then reverse engineer the calculation. Develops financial reasoning skills.",
    "keywords": ["present value", "conceptual learning", "time value of money", "financial intuition", "reverse engineering", "formula derivation"]
  },
  {
    "id": 89,
    "topic": "Financial Portfolio Optimization Iterative Problem Solving",
    "question": "Solve portfolio allocation using iterative approach. budget=10000, stocks=[A,B,C], prices=[50,100,25], expectedReturns=[8%,12%,6%]. Find optimal allocation teaching methodology.",
    "options": [
      "Allocate equally: $3333 each to maximize diversification",
      "System.out.println(\"Iterative Portfolio Optimization:\"); int[] allocation = {0, 0, 0}; double bestReturn = 0; System.out.println(\"Testing allocations...\"); for(int a = 0; a <= 200; a += 10) { for(int b = 0; b <= 100; b += 10) { for(int c = 0; c <= 400; c += 10) { if(a*50 + b*100 + c*25 == 10000) { double expectedReturn = a*50*0.08 + b*100*0.12 + c*25*0.06; if(expectedReturn > bestReturn) { bestReturn = expectedReturn; allocation[0] = a; allocation[1] = b; allocation[2] = c; System.out.println(\"Better allocation found: A=\" + a + \" B=\" + b + \" C=\" + c + \" Return=$\" + expectedReturn); } } } } }",
      "Use linear programming solver",
      "Apply Modern Portfolio Theory formula"
    ],
    "response": "System.out.println(\"Iterative Portfolio Optimization:\"); int[] allocation = {0, 0, 0}; double bestReturn = 0; System.out.println(\"Testing allocations...\"); for(int a = 0; a <= 200; a += 10) { for(int b = 0; b <= 100; b += 10) { for(int c = 0; c <= 400; c += 10) { if(a*50 + b*100 + c*25 == 10000) { double expectedReturn = a*50*0.08 + b*100*0.12 + c*25*0.06; if(expectedReturn > bestReturn) { bestReturn = expectedReturn; allocation[0] = a; allocation[1] = b; allocation[2] = c; System.out.println(\"Better allocation found: A=\" + a + \" B=\" + b + \" C=\" + c + \" Return=$\" + expectedReturn); } } } } }",
    "explanation": "Iterative problem-solving pedagogy: demonstrate brute force optimization before advanced techniques. Students understand constraint checking, objective function evaluation, and optimization through systematic search.",
    "keywords": ["portfolio optimization", "iterative problem solving", "constraint satisfaction", "brute force search", "optimization algorithms", "financial allocation"]
  },
  {
    "id": 90,
    "topic": "Financial Break-Even Analysis Algebraic Thinking",
    "question": "Teach break-even analysis using algebraic reasoning. fixedCosts=50000, variableCostPerUnit=15, sellingPrice=35. Build equation-solving skills step by step.",
    "options": [
      "int breakEven = 50000 / (35 - 15);",
      "System.out.println(\"Algebraic Break-Even Analysis:\"); System.out.println(\"Revenue = Cost (at break-even)\"); System.out.println(\"Revenue: Price × Quantity = 35Q\"); System.out.println(\"Cost: Fixed + Variable = 50000 + 15Q\"); System.out.println(\"Set equal: 35Q = 50000 + 15Q\"); System.out.println(\"Solve: 35Q - 15Q = 50000\"); System.out.println(\"Simplify: 20Q = 50000\"); System.out.println(\"Therefore: Q = 50000 ÷ 20\"); int breakEven = 50000 / (35 - 15); System.out.println(\"Break-even quantity: \" + breakEven + \" units\");",
      "Use break-even calculator tool",
      "Apply direct formula without derivation"
    ],
    "response": "System.out.println(\"Algebraic Break-Even Analysis:\"); System.out.println(\"Revenue = Cost (at break-even)\"); System.out.println(\"Revenue: Price × Quantity = 35Q\"); System.out.println(\"Cost: Fixed + Variable = 50000 + 15Q\"); System.out.println(\"Set equal: 35Q = 50000 + 15Q\"); System.out.println(\"Solve: 35Q - 15Q = 50000\"); System.out.println(\"Simplify: 20Q = 50000\"); System.out.println(\"Therefore: Q = 50000 ÷ 20\"); int breakEven = 50000 / (35 - 15); System.out.println(\"Break-even quantity: \" + breakEven + \" units\");",
    "explanation": "Algebraic thinking pedagogy: show equation setup, manipulation, and solution steps. Students learn to translate business problems into mathematical equations and solve systematically. Builds analytical reasoning skills.",
    "keywords": ["break-even analysis", "algebraic thinking", "equation solving", "business mathematics", "analytical reasoning", "step-by-step algebra"]
  },
  {
    "id": 91,
    "topic": "Financial Investment Strategy Pattern Analysis",
    "question": "Analyze investment patterns using moving averages for trend following. prices[] = {100,102,105,103,108,112,110,115}. Teach 3-day moving average crossover strategy.",
    "options": [
      "Use technical analysis library for moving averages",
      "double[] movingAvg = new double[prices.length-2]; for(int i = 2; i < prices.length; i++) movingAvg[i-2] = (prices[i-2] + prices[i-1] + prices[i]) / 3.0;",
      "System.out.println(\"Moving Average Trend Strategy:\"); System.out.println(\"3-day moving averages:\"); for(int i = 2; i < prices.length; i++) { double ma = (prices[i-2] + prices[i-1] + prices[i]) / 3.0; System.out.println(\"Day \" + (i+1) + \": MA = \" + ma + \", Current = \" + prices[i]); if(prices[i] > ma) System.out.println(\"  Signal: BUY (price above trend)\"); else if(prices[i] < ma) System.out.println(\"  Signal: SELL (price below trend)\"); else System.out.println(\"  Signal: HOLD (price at trend)\"); }",
      "Calculate simple average of all prices"
    ],
    "response": "System.out.println(\"Moving Average Trend Strategy:\"); System.out.println(\"3-day moving averages:\"); for(int i = 2; i < prices.length; i++) { double ma = (prices[i-2] + prices[i-1] + prices[i]) / 3.0; System.out.println(\"Day \" + (i+1) + \": MA = \" + ma + \", Current = \" + prices[i]); if(prices[i] > ma) System.out.println(\"  Signal: BUY (price above trend)\"); else if(prices[i] < ma) System.out.println(\"  Signal: SELL (price below trend)\"); else System.out.println(\"  Signal: HOLD (price at trend)\"); }",
    "explanation": "Pattern analysis pedagogy: combine calculation with interpretation. Students learn moving average calculation AND its application in trend following. Shows how mathematical tools translate to investment decisions.",
    "keywords": ["moving averages", "investment strategy", "pattern analysis", "trend following", "trading signals", "financial algorithms"]
  },
  {
    "id": 92,
    "topic": "Financial Loan Default Probability Statistical Learning",
    "question": "Calculate default probability using historical data analysis. defaults[] = {1,0,1,0,0,1,0,0,0,1} (1=default, 0=current). Teach statistical inference from data.",
    "options": [
      "double defaultRate = Arrays.stream(defaults).average().orElse(0);",
      "System.out.println(\"Statistical Analysis of Default Data:\"); int totalLoans = defaults.length; int defaultCount = 0; System.out.println(\"Analyzing \" + totalLoans + \" loan records...\"); for(int i = 0; i < defaults.length; i++) { if(defaults[i] == 1) { defaultCount++; System.out.println(\"Loan \" + (i+1) + \": DEFAULT\"); } else { System.out.println(\"Loan \" + (i+1) + \": Current\"); } } double defaultProbability = (double)defaultCount / totalLoans; System.out.println(\"Defaults: \" + defaultCount + \" out of \" + totalLoans); System.out.println(\"Default probability: \" + defaultProbability + \" (\" + (defaultProbability*100) + \"%)\");",
      "Use machine learning classification model",
      "Apply complex actuarial formulas"
    ],
    "response": "System.out.println(\"Statistical Analysis of Default Data:\"); int totalLoans = defaults.length; int defaultCount = 0; System.out.println(\"Analyzing \" + totalLoans + \" loan records...\"); for(int i = 0; i < defaults.length; i++) { if(defaults[i] == 1) { defaultCount++; System.out.println(\"Loan \" + (i+1) + \": DEFAULT\"); } else { System.out.println(\"Loan \" + (i+1) + \": Current\"); } } double defaultProbability = (double)defaultCount / totalLoans; System.out.println(\"Defaults: \" + defaultCount + \" out of \" + totalLoans); System.out.println(\"Default probability: \" + defaultProbability + \" (\" + (defaultProbability*100) + \"%)\");",
    "explanation": "Statistical learning pedagogy: show data examination process, counting methodology, and probability calculation. Students understand how historical data informs future predictions in risk assessment.",
    "keywords": ["default probability", "statistical learning", "risk assessment", "data analysis", "probability calculation", "loan analysis"]
  },
  {
    "id": 93,
    "topic": "Financial Currency Exchange Rate Calculation",
    "question": "Calculate multi-currency conversion with pedagogical approach. USD=1000, exchangeRates: USD->EUR=0.85, EUR->GBP=0.88, GBP->USD=1.27. Find arbitrage opportunity step by step.",
    "options": [
      "double finalUSD = 1000 * 0.85 * 0.88 * 1.27;",
      "System.out.println(\"Currency Arbitrage Analysis:\"); double usd = 1000.0; System.out.println(\"Starting amount: $\" + usd); double eur = usd * 0.85; System.out.println(\"USD -> EUR: $\" + usd + \" -> €\" + eur); double gbp = eur * 0.88; System.out.println(\"EUR -> GBP: €\" + eur + \" -> £\" + gbp); double finalUsd = gbp * 1.27; System.out.println(\"GBP -> USD: £\" + gbp + \" -> $\" + finalUsd); double profit = finalUsd - usd; System.out.println(\"Profit: $\" + profit + \" (\" + (profit/usd*100) + \"%)\");",
      "Use currency conversion API",
      "Apply foreign exchange formulas"
    ],
    "response": "System.out.println(\"Currency Arbitrage Analysis:\"); double usd = 1000.0; System.out.println(\"Starting amount: $\" + usd); double eur = usd * 0.85; System.out.println(\"USD -> EUR: $\" + usd + \" -> €\" + eur); double gbp = eur * 0.88; System.out.println(\"EUR -> GBP: €\" + eur + \" -> £\" + gbp); double finalUsd = gbp * 1.27; System.out.println(\"GBP -> USD: £\" + gbp + \" -> $\" + finalUsd); double profit = finalUsd - usd; System.out.println(\"Profit: $\" + profit + \" (\" + (profit/usd*100) + \"%)\");",
    "explanation": "Multi-step calculation pedagogy: show each conversion step with clear output. Students understand currency triangulation and arbitrage detection through systematic calculation tracking.",
    "keywords": ["currency exchange", "arbitrage analysis", "multi-step calculation", "exchange rates", "profit calculation", "international finance"]
  },
  {
    "id": 94,
    "topic": "Financial Investment Diversification Risk Reduction",
    "question": "Demonstrate diversification benefits using correlation analysis. stock1Returns[] = {10,-5,15}, stock2Returns[] = {-3,8,2}. Calculate portfolio variance reduction.",
    "options": [
      "double portfolioReturn = (Arrays.stream(stock1Returns).average().orElse(0) + Arrays.stream(stock2Returns).average().orElse(0)) / 2;",
      "System.out.println(\"Diversification Analysis:\"); System.out.println(\"Individual stock analysis:\"); double sum1 = 0, sum2 = 0; for(int i = 0; i < stock1Returns.length; i++) { sum1 += stock1Returns[i]; sum2 += stock2Returns[i]; System.out.println(\"Period \" + (i+1) + \": Stock1=\" + stock1Returns[i] + \"%, Stock2=\" + stock2Returns[i] + \"%, Portfolio=\" + ((stock1Returns[i] + stock2Returns[i])/2.0) + \"%\"); } double avgStock1 = sum1 / stock1Returns.length; double avgStock2 = sum2 / stock2Returns.length; double avgPortfolio = (avgStock1 + avgStock2) / 2; System.out.println(\"Average returns: Stock1=\" + avgStock1 + \"%, Stock2=\" + avgStock2 + \"%, Portfolio=\" + avgPortfolio + \"%\");",
      "Use portfolio optimization software",
      "Apply Modern Portfolio Theory directly"
    ],
    "response": "System.out.println(\"Diversification Analysis:\"); System.out.println(\"Individual stock analysis:\"); double sum1 = 0, sum2 = 0; for(int i = 0; i < stock1Returns.length; i++) { sum1 += stock1Returns[i]; sum2 += stock2Returns[i]; System.out.println(\"Period \" + (i+1) + \": Stock1=\" + stock1Returns[i] + \"%, Stock2=\" + stock2Returns[i] + \"%, Portfolio=\" + ((stock1Returns[i] + stock2Returns[i])/2.0) + \"%\"); } double avgStock1 = sum1 / stock1Returns.length; double avgStock2 = sum2 / stock2Returns.length; double avgPortfolio = (avgStock1 + avgStock2) / 2; System.out.println(\"Average returns: Stock1=\" + avgStock1 + \"%, Stock2=\" + avgStock2 + \"%, Portfolio=\" + avgPortfolio + \"%\");",
    "explanation": "Diversification pedagogy: show period-by-period comparison between individual stocks and portfolio. Students visually understand how negative correlation reduces portfolio volatility while maintaining returns.",
    "keywords": ["diversification", "risk reduction", "portfolio theory", "correlation analysis", "investment education", "risk management"]
  },
  {
    "id": 95,
    "topic": "Financial Tax Optimization Bracket Calculation",
    "question": "Calculate progressive tax using bracket system teaching. income=85000, brackets: 0-25000=10%, 25001-75000=20%, 75001+=30%. Show marginal vs effective tax rate concepts.",
    "options": [
      "double tax = income * 0.30; // Apply highest bracket rate",
      "double tax = 0; if(income <= 25000) tax = income * 0.10; else if(income <= 75000) tax = 25000*0.10 + (income-25000)*0.20; else tax = 25000*0.10 + 50000*0.20 + (income-75000)*0.30;",
      "System.out.println(\"Progressive Tax Calculation:\"); double tax = 0; double remaining = income; System.out.println(\"Income: $\" + income); if(remaining > 25000) { double bracket1 = 25000 * 0.10; tax += bracket1; remaining -= 25000; System.out.println(\"First $25,000 at 10%: $\" + bracket1); } else { tax = remaining * 0.10; System.out.println(\"All income at 10%: $\" + tax); return; } if(remaining > 50000) { double bracket2 = 50000 * 0.20; tax += bracket2; remaining -= 50000; System.out.println(\"Next $50,000 at 20%: $\" + bracket2); } else { double bracket2 = remaining * 0.20; tax += bracket2; System.out.println(\"Remaining $\" + remaining + \" at 20%: $\" + bracket2); return; } double bracket3 = remaining * 0.30; tax += bracket3; System.out.println(\"Remaining $\" + remaining + \" at 30%: $\" + bracket3); System.out.println(\"Total tax: $\" + tax + \" (\" + (tax/income*100) + \"% effective rate)\");",
      "Use tax software calculation"
    ],
    "response": "System.out.println(\"Progressive Tax Calculation:\"); double tax = 0; double remaining = income; System.out.println(\"Income: $\" + income); if(remaining > 25000) { double bracket1 = 25000 * 0.10; tax += bracket1; remaining -= 25000; System.out.println(\"First $25,000 at 10%: $\" + bracket1); } else { tax = remaining * 0.10; System.out.println(\"All income at 10%: $\" + tax); return; } if(remaining > 50000) { double bracket2 = 50000 * 0.20; tax += bracket2; remaining -= 50000; System.out.println(\"Next $50,000 at 20%: $\" + bracket2); } else { double bracket2 = remaining * 0.20; tax += bracket2; System.out.println(\"Remaining $\" + remaining + \" at 20%: $\" + bracket2); return; } double bracket3 = remaining * 0.30; tax += bracket3; System.out.println(\"Remaining $\" + remaining + \" at 30%: $\" + bracket3); System.out.println(\"Total tax: $\" + tax + \" (\" + (tax/income*100) + \"% effective rate)\");",
    "explanation": "Tax bracket pedagogy: demonstrate progressive taxation step-by-step. Students understand marginal rates, bracket filling, and effective rate calculation. Clarifies common tax misconceptions.",
    "keywords": ["progressive taxation", "tax brackets", "marginal tax rate", "effective tax rate", "tax optimization", "financial planning"]
  },
  {
    "id": 96,
    "topic": "Financial Retirement Planning Future Value Scenarios",
    "question": "Model retirement savings scenarios using algorithmic thinking. monthlyContribution=500, years=30, annualReturn=7%. Compare different contribution strategies pedagogically.",
    "options": [
      "double futureValue = 500 * 12 * 30 * Math.pow(1.07, 30);",
      "System.out.println(\"Retirement Savings Scenarios:\"); double monthlyRate = 0.07 / 12; int months = 30 * 12; System.out.println(\"Scenario 1: Fixed $500/month\"); double fv1 = 0; for(int i = 0; i < months; i++) { fv1 = (fv1 + 500) * (1 + monthlyRate); } System.out.println(\"Future Value: $\" + fv1); System.out.println(\"Scenario 2: Increasing $500/month by 3% annually\"); double fv2 = 0; double contribution = 500; for(int year = 0; year < 30; year++) { for(int month = 0; month < 12; month++) { fv2 = (fv2 + contribution) * (1 + monthlyRate); } contribution *= 1.03; System.out.println(\"Year \" + (year+1) + \": Monthly contribution $\" + contribution + \", Balance $\" + fv2); }",
      "Use retirement calculator software",
      "Apply annuity formula directly"
    ],
    "response": "System.out.println(\"Retirement Savings Scenarios:\"); double monthlyRate = 0.07 / 12; int months = 30 * 12; System.out.println(\"Scenario 1: Fixed $500/month\"); double fv1 = 0; for(int i = 0; i < months; i++) { fv1 = (fv1 + 500) * (1 + monthlyRate); } System.out.println(\"Future Value: $\" + fv1); System.out.println(\"Scenario 2: Increasing $500/month by 3% annually\"); double fv2 = 0; double contribution = 500; for(int year = 0; year < 30; year++) { for(int month = 0; month < 12; month++) { fv2 = (fv2 + contribution) * (1 + monthlyRate); } contribution *= 1.03; System.out.println(\"Year \" + (year+1) + \": Monthly contribution $\" + contribution + \", Balance $\" + fv2); }",
    "explanation": "Scenario modeling pedagogy: compare different savings strategies using iterative calculation. Students understand compound growth, contribution escalation, and long-term impact of financial decisions through simulation.",
    "keywords": ["retirement planning", "scenario modeling", "compound growth", "savings strategies", "future value", "financial simulation"]
  },
  {
    "id": 97,
    "topic": "Financial Bond Pricing Yield Calculation",
    "question": "Calculate bond yield to maturity using iterative approximation method. faceValue=1000, couponRate=5%, currentPrice=950, yearsToMaturity=10. Teach iterative solving approach.",
    "options": [
      "Use financial calculator bond function",
      "double ytm = (50 + (1000-950)/10) / ((1000+950)/2);",
      "System.out.println(\"Bond Yield Approximation:\"); double couponPayment = 1000 * 0.05; double priceDiscount = 1000 - 950; double avgPriceDiscount = priceDiscount / 10; System.out.println(\"Annual coupon: $\" + couponPayment); System.out.println(\"Total discount: $\" + priceDiscount + \" over \" + 10 + \" years\"); System.out.println(\"Average annual discount: $\" + avgPriceDiscount); double avgPrice = (1000 + 950) / 2; double approxYtm = (couponPayment + avgPriceDiscount) / avgPrice; System.out.println(\"Approximate YTM: \" + (approxYtm * 100) + \"%\"); System.out.println(\"(This is simplified approximation method)\");",
      "Apply complex bond pricing formulas"
    ],
    "response": "System.out.println(\"Bond Yield Approximation:\"); double couponPayment = 1000 * 0.05; double priceDiscount = 1000 - 950; double avgPriceDiscount = priceDiscount / 10; System.out.println(\"Annual coupon: $\" + couponPayment); System.out.println(\"Total discount: $\" + priceDiscount + \" over \" + 10 + \" years\"); System.out.println(\"Average annual discount: $\" + avgPriceDiscount); double avgPrice = (1000 + 950) / 2; double approxYtm = (couponPayment + avgPriceDiscount) / avgPrice; System.out.println(\"Approximate YTM: \" + (approxYtm * 100) + \"%\"); System.out.println(\"(This is simplified approximation method)\");",
    "explanation": "Approximation method pedagogy: teach simplified yield calculation before complex formulas. Students understand bond components (coupon, discount, average price) and yield concept through decomposition.",
    "keywords": ["bond pricing", "yield to maturity", "approximation methods", "financial instruments", "iterative solving", "bond analysis"]
  },
  {
    "id": 98,
    "topic": "Financial Economic Indicator Analysis Trend Detection",
    "question": "Analyze economic indicators using trend detection algorithms. gdpGrowth[] = {2.1, 2.3, 1.8, 1.5, 1.2, 0.8, 0.5}. Detect recession pattern (2+ consecutive quarters of decline).",
    "options": [
      "boolean recession = gdpGrowth[6] < gdpGrowth[0];",
      "System.out.println(\"Economic Trend Analysis:\"); boolean inRecession = false; int consecutiveDeclines = 0; for(int i = 1; i < gdpGrowth.length; i++) { if(gdpGrowth[i] < gdpGrowth[i-1]) { consecutiveDeclines++; System.out.println(\"Q\" + (i+1) + \": Decline (\" + gdpGrowth[i] + \"% < \" + gdpGrowth[i-1] + \"%)\"); if(consecutiveDeclines >= 2 && !inRecession) { System.out.println(\"*** RECESSION DETECTED at Q\" + (i+1) + \" ***\"); inRecession = true; } } else { if(consecutiveDeclines > 0) System.out.println(\"Q\" + (i+1) + \": Growth resumed (\" + gdpGrowth[i] + \"% > \" + gdpGrowth[i-1] + \"%)\"); consecutiveDeclines = 0; } }",
      "Use econometric modeling software",
      "Apply complex statistical tests"
    ],
    "response": "System.out.println(\"Economic Trend Analysis:\"); boolean inRecession = false; int consecutiveDeclines = 0; for(int i = 1; i < gdpGrowth.length; i++) { if(gdpGrowth[i] < gdpGrowth[i-1]) { consecutiveDeclines++; System.out.println(\"Q\" + (i+1) + \": Decline (\" + gdpGrowth[i] + \"% < \" + gdpGrowth[i-1] + \"%)\"); if(consecutiveDeclines >= 2 && !inRecession) { System.out.println(\"*** RECESSION DETECTED at Q\" + (i+1) + \" ***\"); inRecession = true; } } else { if(consecutiveDeclines > 0) System.out.println(\"Q\" + (i+1) + \": Growth resumed (\" + gdpGrowth[i] + \"% > \" + gdpGrowth[i-1] + \"%)\"); consecutiveDeclines = 0; } }",
    "explanation": "Trend detection pedagogy: teach pattern recognition in economic data using state tracking. Students understand sequential analysis, pattern counting, and economic indicator interpretation through algorithmic approach.",
    "keywords": ["economic indicators", "trend detection", "recession analysis", "pattern recognition", "economic data", "state tracking"]
  },
  {
    "id": 99,
    "topic": "Financial Options Pricing Basic Model",
    "question": "Introduce options pricing using simplified binomial model. stockPrice=100, strikePrice=105, upMove=1.1, downMove=0.9, probability=0.6. Teach option valuation step by step.",
    "options": [
      "Use Black-Scholes formula directly",
      "double optionValue = Math.max(stockPrice - strikePrice, 0);",
      "System.out.println(\"Simple Binomial Options Model:\"); double upPrice = stockPrice * 1.1; double downPrice = stockPrice * 0.9; System.out.println(\"Current stock price: $\" + stockPrice); System.out.println(\"Possible future prices:\"); System.out.println(\"  Up scenario (60%): $\" + upPrice); System.out.println(\"  Down scenario (40%): $\" + downPrice); double upPayoff = Math.max(upPrice - strikePrice, 0); double downPayoff = Math.max(downPrice - strikePrice, 0); System.out.println(\"Call option payoffs:\"); System.out.println(\"  If up: max($\" + upPrice + \" - $\" + strikePrice + \", 0) = $\" + upPayoff); System.out.println(\"  If down: max($\" + downPrice + \" - $\" + strikePrice + \", 0) = $\" + downPayoff); double expectedPayoff = 0.6 * upPayoff + 0.4 * downPayoff; System.out.println(\"Expected payoff: $\" + expectedPayoff);",
      "Apply complex derivatives formulas"
    ],
    "response": "System.out.println(\"Simple Binomial Options Model:\"); double upPrice = stockPrice * 1.1; double downPrice = stockPrice * 0.9; System.out.println(\"Current stock price: $\" + stockPrice); System.out.println(\"Possible future prices:\"); System.out.println(\"  Up scenario (60%): $\" + upPrice); System.out.println(\"  Down scenario (40%): $\" + downPrice); double upPayoff = Math.max(upPrice - strikePrice, 0); double downPayoff = Math.max(downPrice - strikePrice, 0); System.out.println(\"Call option payoffs:\"); System.out.println(\"  If up: max($\" + upPrice + \" - $\" + strikePrice + \", 0) = $\" + upPayoff); System.out.println(\"  If down: max($\" + downPrice + \" - $\" + strikePrice + \", 0) = $\" + downPayoff); double expectedPayoff = 0.6 * upPayoff + 0.4 * downPayoff; System.out.println(\"Expected payoff: $\" + expectedPayoff);",
    "explanation": "Options pricing pedagogy: introduce complex derivatives through simplified binomial model. Students understand option payoffs, scenario analysis, and expected value calculation before advanced pricing models.",
    "keywords": ["options pricing", "binomial model", "derivatives", "payoff calculation", "expected value", "financial modeling"]
  },
  {
    "id": 100,
    "topic": "Financial Capital Budgeting NPV Decision Framework",
    "question": "Evaluate investment project using NPV decision framework. initialInvestment=100000, annualCashFlows=[30000,35000,40000,25000], discountRate=10%. Build decision-making algorithm.",
    "options": [
      "double npv = -100000 + 30000/1.1 + 35000/1.21 + 40000/1.331 + 25000/1.4641;",
      "System.out.println(\"NPV Investment Decision Framework:\"); double npv = -initialInvestment; System.out.println(\"Initial investment: $\" + initialInvestment); System.out.println(\"Cash flow analysis:\"); for(int year = 0; year < annualCashFlows.length; year++) { double discountFactor = Math.pow(1.10, year + 1); double presentValue = annualCashFlows[year] / discountFactor; npv += presentValue; System.out.println(\"Year \" + (year+1) + \": $\" + annualCashFlows[year] + \" ÷ \" + discountFactor + \" = $\" + presentValue); } System.out.println(\"Net Present Value: $\" + npv); if(npv > 0) System.out.println(\"DECISION: ACCEPT PROJECT (NPV > 0)\"); else System.out.println(\"DECISION: REJECT PROJECT (NPV < 0)\");",
      "Use financial calculator NPV function",
      "Apply IRR analysis instead"
    ],
    "response": "System.out.println(\"NPV Investment Decision Framework:\"); double npv = -initialInvestment; System.out.println(\"Initial investment: $\" + initialInvestment); System.out.println(\"Cash flow analysis:\"); for(int year = 0; year < annualCashFlows.length; year++) { double discountFactor = Math.pow(1.10, year + 1); double presentValue = annualCashFlows[year] / discountFactor; npv += presentValue; System.out.println(\"Year \" + (year+1) + \": $\" + annualCashFlows[year] + \" ÷ \" + discountFactor + \" = $\" + presentValue); } System.out.println(\"Net Present Value: $\" + npv); if(npv > 0) System.out.println(\"DECISION: ACCEPT PROJECT (NPV > 0)\"); else System.out.println(\"DECISION: REJECT PROJECT (NPV < 0)\");",
    "explanation": "Capital budgeting pedagogy: teach investment evaluation through systematic NPV calculation and decision framework. Students understand time value of money, discount factors, and rule-based decision making in finance.",
    "keywords": ["capital budgeting", "NPV analysis", "investment decisions", "decision framework", "present value", "financial evaluation"]
  }
]
}
